<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hexo站点的优化方法</title>
      <link href="/optimization-of-hexo-site/"/>
      <url>/optimization-of-hexo-site/</url>
      
        <content type="html"><![CDATA[<h4 id="使用USTC-Google-Fonts加速服务"><a href="#使用USTC-Google-Fonts加速服务" class="headerlink" title="使用USTC Google Fonts加速服务"></a>使用USTC Google Fonts加速服务</h4><p>谷歌字体api在国内的使用体验一直很差，所以当我想用自己喜欢的字体的时候从google fonts加载过来就会很慢，用户体验极差。<br>使用USTC Google Fonts加速服务其实很简单，将<code>theme/next/_config.xml</code>中<code>fonts</code>中的<code>host</code>选项设置为<code>fonts.lug.ustc.edu.cn</code>即可（默认为：<code>fonts.googleapi.com</code>）。具体可以<code>参考参考资料１</code>。</p><h4 id="将Github-Pages部署到Netlify"><a href="#将Github-Pages部署到Netlify" class="headerlink" title="将Github Pages部署到Netlify"></a>将Github Pages部署到Netlify</h4><h4 id="将博客迁移至Coding-Pages"><a href="#将博客迁移至Coding-Pages" class="headerlink" title="将博客迁移至Coding Pages"></a>将博客迁移至Coding Pages</h4><ol><li><p>国外的cdn解析始终是差点意思，将静态博客迁移至<code>Coding.net</code>提供的<code>Coding Pages</code>服务，体验比<code>Github Pages</code>和<code>Netlify</code>好得多。</p></li><li><p>本篇文章不讨论个人服务器部署。</p></li></ol><h4 id="使用阿里云OSS存储"><a href="#使用阿里云OSS存储" class="headerlink" title="使用阿里云OSS存储"></a>使用阿里云OSS存储</h4><pre><code>在阿里云上开通OSS存储，搭建自己的图床等。</code></pre><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ol><li><a href="https://lug.ustc.edu.cn/wiki/lug/services/googlefonts">LUG@USTC Google Fonts加速服务</a></li><li><a href="http://theme-next.iissnan.com/theme-settings.html#fonts-customization">Next最新使用文档</a></li><li><a href="https://io-oi.me/">优秀博客</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习笔记 3</title>
      <link href="/git-study-note-3/"/>
      <url>/git-study-note-3/</url>
      
        <content type="html"><![CDATA[<h4 id="fetch、pull与push"><a href="#fetch、pull与push" class="headerlink" title="fetch、pull与push"></a>fetch、pull与push</h4><ol><li>了解fast-forwards</li><li>fetch从远端拉到本地保持一致</li><li>当remote与本地仓库不一致时的处理办法</li></ol><ul><li>先fetch再merge</li><li>直接pull</li><li>git rebase</li></ul><ol start="3"><li>推送到remote</li></ol><h4 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h4><h5 id="不同人修改不同文件该如何处理"><a href="#不同人修改不同文件该如何处理" class="headerlink" title="不同人修改不同文件该如何处理"></a>不同人修改不同文件该如何处理</h5><pre><code>git merge同一开发分支。</code></pre><h5 id="不同人修改了相同文件的不同区域"><a href="#不同人修改了相同文件的不同区域" class="headerlink" title="不同人修改了相同文件的不同区域"></a>不同人修改了相同文件的不同区域</h5><pre><code>协作前git pull保持仓库最新，再进行push（留意ahead与behind信息）。</code></pre><h5 id="不同人修改了同文件的同一区域"><a href="#不同人修改了同文件的同一区域" class="headerlink" title="不同人修改了同文件的同一区域"></a>不同人修改了同文件的同一区域</h5><pre><code>及时pull来同步变更，这个情况会提示conflict，这时需要打开冲突文件（文件内会有提示信息），选择保留的信息并删除提示信息。修改完成后提交commit再进行push。</code></pre><h5 id="不同人同时变更了文件名及其内容"><a href="#不同人同时变更了文件名及其内容" class="headerlink" title="不同人同时变更了文件名及其内容"></a>不同人同时变更了文件名及其内容</h5><pre><code>pull最新内容。当其中一位开发人员变更了姓名与其内容之后，另一位开发人员直接进行pull即可。</code></pre><h5 id="多人修改文件名"><a href="#多人修改文件名" class="headerlink" title="多人修改文件名"></a>多人修改文件名</h5><pre><code>当该情况发生时，后提交的开发人员执行pull之后会报conflict，并保留了这两个不同文件名的文件为两个独立文件。两人协商后选择保留一份，git add [要保留的文件]、git rm [不需要保留的文件]，再进行commit，最后push。</code></pre><h5 id="禁止向继承分支执行push-f"><a href="#禁止向继承分支执行push-f" class="headerlink" title="禁止向继承分支执行push -f"></a>禁止向继承分支执行push -f</h5><pre><code>-f: force updates</code></pre><h5 id="禁止向集成分支执行变更历史的操作"><a href="#禁止向集成分支执行变更历史的操作" class="headerlink" title="禁止向集成分支执行变更历史的操作"></a>禁止向集成分支执行变更历史的操作</h5><pre><code>公共的分支进制被拉到本地进行rebase行为。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习笔记 2</title>
      <link href="/git-study-note-2/"/>
      <url>/git-study-note-2/</url>
      
        <content type="html"><![CDATA[<h4 id="commit-tree与blob的对应关系"><a href="#commit-tree与blob的对应关系" class="headerlink" title="commit, tree与blob的对应关系"></a>commit, tree与blob的对应关系</h4><ol><li>一个commit对应一个tree（唯一一个）</li><li>一个tree可以看作是一次commit之后整个项目的一个快照</li><li>一个tree可能也会包含多个tree</li><li>一个blob对应一个文件</li></ol><h4 id="分离头指针注意的问题"><a href="#分离头指针注意的问题" class="headerlink" title="分离头指针注意的问题"></a>分离头指针注意的问题</h4><pre><code>当切换到没有绑定分支的commit时，并对其当中的文件修改，最终提交commit保存后会出现&quot;warning: you are leaving 1 sommit behind, not connected to any of your branches.&quot;这时的commit被git看作不重要，可能会被git所清理，如果你要保存这个commit就要新建分支（git branch new-branch-name [分支hash]）</code></pre><h4 id="删除不需要的分支"><a href="#删除不需要的分支" class="headerlink" title="删除不需要的分支"></a>删除不需要的分支</h4><pre class=" language-git"><code class="language-git">git branch -d [branch-name / hash]</code></pre><h4 id="修改commit和massage"><a href="#修改commit和massage" class="headerlink" title="修改commit和massage"></a>修改commit和massage</h4><ol><li>修改最新的commit</li></ol><pre class=" language-git"><code class="language-git">git commit --amend</code></pre><ol start="2"><li>修改老旧的commit</li></ol><pre class=" language-git"><code class="language-git">git rebase -i [privious-commit-hash]<span class="token comment" spellcheck="true"># 按照提示修改</span><span class="token comment" spellcheck="true"># 将pick改为reward</span></code></pre><ol start="3"><li>合并多次的commit</li></ol><pre class=" language-git"><code class="language-git">git rebase -i [oldest-commit-hash]<span class="token comment" spellcheck="true"># 按照提示修改</span><span class="token comment" spellcheck="true"># 将pick改为squash</span></code></pre><ol start="4"><li>合并不连续的commit</li></ol><pre class=" language-git"><code class="language-git">git rebase -i [oldest-commit-hash]<span class="token comment" spellcheck="true"># 未显示出来的需要用到的commit要按照先后顺序手动添加进来</span><span class="token comment" spellcheck="true"># 把要合并的commit按照先后顺序放在一起</span><span class="token comment" spellcheck="true"># 将pick改为squash</span></code></pre><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><h5 id="文件的差异"><a href="#文件的差异" class="headerlink" title="文件的差异"></a>文件的差异</h5><ol><li>比较暂存区与head指向的文件差异</li></ol><pre class=" language-git"><code class="language-git">git diff --cached</code></pre><ol start="2"><li>比较工作区与暂存区文件差异</li></ol><pre class=" language-git"><code class="language-git">git diff<span class="token comment" spellcheck="true"># 所以说git diff命令默认比较的是工作区和暂存区的区别，默认所有文件</span>git diff -- file.name<span class="token comment" spellcheck="true"># 指定文件的差异</span></code></pre><h5 id="文件提交与回退"><a href="#文件提交与回退" class="headerlink" title="文件提交与回退"></a>文件提交与回退</h5><ol><li><p>暂存区恢复成和HEAD一样</p><p> 命令：git reset HEAD <file>…</p></li></ol><pre class=" language-git"><code class="language-git">git reset HEAD<span class="token comment" spellcheck="true"># 清空暂存区所有文件（即取消暂存）</span></code></pre><ol start="2"><li><p>工作区恢复成和暂存区一样</p><p> 命令：git checkout – <file>…</p></li></ol><pre class=" language-git"><code class="language-git">git checkout -- file.name</code></pre><ol start="3"><li><p>取消暂存区部分文件的暂存</p><p> 命令：git reset HEAD <file>…</p></li></ol><pre class=" language-git"><code class="language-git">git resset HEAD -- file1.name file2.name # ...</code></pre><ol start="4"><li>清除最近几次提交</li></ol><pre class=" language-git"><code class="language-git">git reset --hard [target-commit-hash]</code></pre><ol start="5"><li>查看不同提交的指定文件的差异</li></ol><pre class=" language-git"><code class="language-git"><span class="token comment" spellcheck="true"># 比较两分支的差异</span>git diff branch1 branch2<span class="token comment" spellcheck="true"># 比较特定文件</span>git diff branch1 branch2 -- file.name<span class="token comment" spellcheck="true"># 直接比较两个commit</span>git diff commit-hash-1 commit-hash-2 -- file.name</code></pre><ol start="6"><li>删除文件的正确方法</li></ol><pre class=" language-git"><code class="language-git">git rm file.name</code></pre><ol start="7"><li>紧急任务处理</li></ol><pre class=" language-git"><code class="language-git"><span class="token comment" spellcheck="true"># 保存当前状态以便处理紧急事件</span>git stash<span class="token comment" spellcheck="true"># 处理完之后再恢复</span>git stash pop # 或 git stash apply<span class="token comment" spellcheck="true"># pop 和 apply的区别</span><span class="token comment" spellcheck="true"># pop恢复并丢掉stash list内容，apply不会</span><span class="token comment" spellcheck="true"># 查看stash列表</span>git stash list</code></pre><h5 id="指定不需要git管理的文件"><a href="#指定不需要git管理的文件" class="headerlink" title="指定不需要git管理的文件"></a>指定不需要git管理的文件</h5><pre><code>.gitignore文件</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective Python 学习笔记 4</title>
      <link href="/effective-python-study-note-4/"/>
      <url>/effective-python-study-note-4/</url>
      
        <content type="html"><![CDATA[<h4 id="尽量使用异常来表示特殊情况，而不要返回None"><a href="#尽量使用异常来表示特殊情况，而不要返回None" class="headerlink" title="尽量使用异常来表示特殊情况，而不要返回None"></a>尽量使用异常来表示特殊情况，而不要返回None</h4><pre><code>    _表示用不到的变量</code></pre><h5 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h5><ol><li>用None这个返回值来表示特殊意义的函数，很容易使调用者犯错，以为None和0及空字符串之类的值，在表达式里面都会评估为False</li><li>函数遇到特特殊情况时应该抛出异常，而不是返回None</li></ol><h4 id="了解如何在闭包里使用外围作用域中的变量"><a href="#了解如何在闭包里使用外围作用域中的变量" class="headerlink" title="了解如何在闭包里使用外围作用域中的变量"></a>了解如何在闭包里使用外围作用域中的变量</h4><pre class=" language-python"><code class="language-python">    <span class="token triple-quoted-string string">'''        eg. 有一份列表，其中元素都是数字，现在对其排序，要把出现在某个群组内的数字，放在群组外的那些数字之前。    '''</span>    <span class="token keyword">def</span> <span class="token function">sort_pri</span><span class="token punctuation">(</span>values<span class="token punctuation">,</span> group<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> x <span class="token keyword">in</span> group<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span>        values<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key <span class="token operator">=</span> helper<span class="token punctuation">)</span>        <span class="token triple-quoted-string string">'''            上述函数成立的原因：                1. 函数是一等对象(first-class object)                2. python支持闭包                3. python中使用特殊的规则来比较两个元组。它首先比较各元组中下标为0的对应元素，如果相等，再比较下标为1的元素，如果还是想等，就继续依次比较。        '''</span>    numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span>    group <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;2, 3, 5, 7&amp;#125;</span>    sort_pri<span class="token punctuation">(</span>numbers<span class="token punctuation">,</span> group<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span>    <span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span></code></pre><h5 id="要点-1"><a href="#要点-1" class="headerlink" title="要点"></a>要点</h5><ol><li>对于定义在某作用域内的闭包来说，它可以引用这些作用域中的变量</li><li>使用默认方式对闭包内的变量赋值，不会影响外围作用域的同名变量</li><li>在python 3中，程序可以在闭包内用nonlocal语句来修饰某个名称，使该闭包能够修改外围作用域中的同名变量</li><li>除了简单的函数，尽量不要使用nonlocal语句</li></ol><h4 id="考虑使用生成器来改写直接返回列表的函数"><a href="#考虑使用生成器来改写直接返回列表的函数" class="headerlink" title="考虑使用生成器来改写直接返回列表的函数"></a>考虑使用生成器来改写直接返回列表的函数</h4><pre class=" language-python"><code class="language-python">    <span class="token comment" spellcheck="true"># eg.返回字符串中英文单词的首字母和其下标</span>    <span class="token keyword">def</span> <span class="token function">index_words</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">:</span>        result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> text<span class="token punctuation">:</span>            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> index<span class="token punctuation">,</span> letter <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> letter <span class="token operator">==</span> <span class="token string">' '</span><span class="token punctuation">:</span>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> result    words <span class="token operator">=</span> <span class="token string">'I am python'</span>    re <span class="token operator">=</span> index_words<span class="token punctuation">(</span>words<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">)</span>    <span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span></code></pre><p>以上程序的问题：</p><ol><li>代码拥挤，每次找到新的结果，都要调用append方法。而我们真正强调的不是对append的调用，而是该方法给列表中添加的那个值且函数首位都要对resut进行创建和返回</li></ol><pre class=" language-python"><code class="language-python">    <span class="token comment" spellcheck="true"># 生成器改写</span>    <span class="token keyword">def</span> index<span class="token punctuation">)</span>words_iter<span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> text<span class="token punctuation">:</span>            <span class="token keyword">yield</span> <span class="token number">0</span>        <span class="token keyword">for</span> index<span class="token punctuation">,</span> letter <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> letter <span class="token operator">==</span> <span class="token string">' '</span><span class="token punctuation">:</span>                <span class="token keyword">yield</span> index <span class="token operator">+</span> <span class="token number">1</span>        <span class="token comment" spellcheck="true">### ···</span>        re <span class="token operator">=</span> list<span class="token punctuation">(</span>index_words_iter<span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><ol start="2"><li>index_words函数在它返回前，要把所有结果都放在列表中。如果数据量非常大，那么程序可能会耗尽内存。用生成器改写后，可以应对任意长度的输入数据</li></ol><h5 id="要点-2"><a href="#要点-2" class="headerlink" title="要点"></a>要点</h5><ol><li>使用时生成器比用list返回结果更加清晰</li><li>由生成器函数所返回的那个迭代器，可以把生成器函数体中，传给yield表达式的那些值，逐次生产出来</li><li>无论数据量多大，生成器都能产生一系列输出，不会对内存造成压力</li></ol><h4 id="在参数上面迭代时要多加小心"><a href="#在参数上面迭代时要多加小心" class="headerlink" title="在参数上面迭代时要多加小心"></a>在参数上面迭代时要多加小心</h4><pre><code>    细节见书本第17条</code></pre><h5 id="要点-3"><a href="#要点-3" class="headerlink" title="要点"></a>要点</h5><ol><li>如果参数是迭代器，那么可能会导致奇怪的行为并错失某些值</li><li>python的迭代器协议，描述了容器和迭代器应该如何与iter和next内置函数、for循环及相关表达式相互配合</li><li>把__iter__方法时限为生成器，即可定义自己的容器类型</li><li>想判断某个值是迭代器还是容器，可以拿该值为参数，两侧调用iter函数，若结果相同，则是迭代器，调用内置的next函数，即可令该迭代器前进一步</li></ol><h4 id="用数量可变的位置参数减少视觉杂讯"><a href="#用数量可变的位置参数减少视觉杂讯" class="headerlink" title="用数量可变的位置参数减少视觉杂讯"></a>用数量可变的位置参数减少视觉杂讯</h4><pre><code>    令函数接受可选位置参数（由于这种参数习惯上写为*args，所以又称为star args，星号参数），能够使代码更加清晰，并减少视觉杂讯（visual noise）。    visual noise：一种比喻，意思是使代码看起来不要太过杂乱，以强调其中的重要内容。</code></pre><h5 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h5><ol><li>变长参数在传给函数时，总是先转化为元组。这就意味着，如果用带有*操作符的生成器为参数，来调用这种参数，python必须把该生成器完整迭代一轮，并把所生成的每个值，都放入元组之中。这可能会消耗大量内存。所以只有当我们确定参数个数较少时，才采用这种写法</li><li>如果以后要给函数添加新的位置参数，那就必须修改原来调用该函数的那些旧代码</li></ol><h5 id="要点-4"><a href="#要点-4" class="headerlink" title="要点"></a>要点</h5><ol><li>def语句中用*args，即可令函数接受数量可变的位置参数</li><li>调用函数时，可以采用*操作符，把序列中的元素当成位置参数，传给该函数</li><li>对生成器使用*操作符，可能导致内存耗尽</li><li>在已经接受*args参数的函数上继续添加位置参数，可能会产生难以排查的bug</li></ol><h4 id="用关键字参数来表达可选行为"><a href="#用关键字参数来表达可选行为" class="headerlink" title="用关键字参数来表达可选行为"></a>用关键字参数来表达可选行为</h4><pre class=" language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span>arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> arg1 <span class="token operator">+</span> arg2    <span class="token comment" spellcheck="true"># 以下写法等效</span>    func<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    func<span class="token punctuation">(</span>arg1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    func<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> arg2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span>    func<span class="token punctuation">(</span>arg1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> arg2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span></code></pre><h5 id="关键字参数的好处"><a href="#关键字参数的好处" class="headerlink" title="关键字参数的好处"></a>关键字参数的好处</h5><ol><li>易于理解，参数含义与参数值都呈现在面前</li><li>可以在函数中提供默认值</li><li>它可以提供一种扩充函数参数的有效方式，使得扩充之后的函数依然能与原有的那些调用代码兼容</li></ol><h5 id="要点-5"><a href="#要点-5" class="headerlink" title="要点"></a>要点</h5><ol><li>函数参数可以按照位置或关键字来指定</li><li>只是用位置参数来调用函数，可能会导致这些参数数值含义不够明确，而关键字参数则能够阐明每个参数的意图</li><li>给函数添加新行为时，可以使用带默认值的关键字参数，以便与原有的函数点用代码保持兼容</li><li>可选的关键字参数，总是应该以关键字形式来指定，而不是以位置参数的形式来指定</li></ol><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ol><li><a href="https://blog.csdn.net/u013380694/article/details/90019571">python 闭包和装饰器详解</a></li><li><a href="https://www.runoob.com/python3/python3-att-list-sort.html">Python3 List sort()方法</a></li><li><a href="https://www.jianshu.com/p/9dd355ab4e5d">深入理解 Python yield</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective Python 学习笔记 3</title>
      <link href="/effective-python-study-note-3/"/>
      <url>/effective-python-study-note-3/</url>
      
        <content type="html"><![CDATA[<h4 id="不要在for和while循环后面写else语句块"><a href="#不要在for和while循环后面写else语句块" class="headerlink" title="不要在for和while循环后面写else语句块"></a>不要在for和while循环后面写else语句块</h4><pre><code>Python提供了一种很多编程语言都不支持的功能，可以在循环内部的语句块后面直接写else块。</code></pre><pre class=" language-python"><code class="language-python">    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Loop %s'</span> <span class="token operator">%</span> i<span class="token punctuation">)</span>    <span class="token keyword">else</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Loop done!'</span><span class="token punctuation">)</span>    <span class="token operator">>></span><span class="token operator">></span>    Loop <span class="token number">0</span>    Loop <span class="token number">1</span>    Loop <span class="token number">2</span>    Loop done!    <span class="token comment" spellcheck="true"># 即程序没有成功执行完，就会执行else语句</span></code></pre><h5 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h5><ol><li>只有当整个循环猪蹄都没有遇到break语句时，循环后面的else块才会执行</li><li>循环后加else块，这种写法不直观，又容易引起误解</li></ol><h4 id="合理利用try-x2F-except-x2F-else-x2F-finally结构中的每个代码块"><a href="#合理利用try-x2F-except-x2F-else-x2F-finally结构中的每个代码块" class="headerlink" title="合理利用try&#x2F;except&#x2F;else&#x2F;finally结构中的每个代码块"></a>合理利用try&#x2F;except&#x2F;else&#x2F;finally结构中的每个代码块</h4><h5 id="finally块"><a href="#finally块" class="headerlink" title="finally块"></a>finally块</h5><ul><li>如果既要将异常向上传播，又要在异常发生时执行清理工作，尝试使用try&#x2F;finally结构</li></ul><pre class=" language-python"><code class="language-python">    <span class="token comment" spellcheck="true"># 这是一项常见的用途，就是确保能够可靠的关闭文件句柄</span>    handle <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">'file'</span><span class="token punctuation">)</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        data <span class="token operator">=</span> handle<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">finally</span><span class="token punctuation">:</span>        handle<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># read方法所抛出的异常会向上传播给调用方，而finally块中的close方法将一定会被执行。</span>    <span class="token comment" spellcheck="true"># open方法一定要放在try之外，因为如果打开文件时发生异常，那么程序应该跳过finally块。</span></code></pre><h5 id="else块"><a href="#else块" class="headerlink" title="else块"></a>else块</h5><ul><li>try&#x2F;except&#x2F;else结构可以清晰地描述出哪些异常会由自己地代码处理、哪些异常会传播到上一级。</li><li>如果try没有异常，那么就执行else块。</li></ul><pre class=" language-python"><code class="language-python">    <span class="token keyword">def</span> <span class="token function">load_json_key</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            result_dict <span class="token operator">=</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>data<span class="token punctuation">)</span>        <span class="token keyword">except</span> ValueError <span class="token keyword">as</span> e<span class="token punctuation">:</span>            <span class="token keyword">raise</span> KeyError <span class="token keyword">from</span> e        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> result_dict<span class="token punctuation">[</span>key<span class="token punctuation">]</span></code></pre><p><a href="https://blog.csdn.net/jpch89/article/details/84315444">Raise和Raise…from…的区别</a></p><h5 id="混合使用"><a href="#混合使用" class="headerlink" title="混合使用"></a>混合使用</h5><pre><code>详见书本</code></pre><h5 id="要点-1"><a href="#要点-1" class="headerlink" title="要点"></a>要点</h5><ol><li>无论try块是否发生异常，都可利用try&#x2F;finally符合语句中的finally块来执行清理工作</li><li>else块可以用来缩减try块中的代码量，并把没有发生异常时索要执行的语句与try&#x2F;except代码块隔开</li><li>顺利运行try块后，若想使某些操作能在finally块的清理代码之前执行，则可将这些操作写到else块中</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective Python 学习笔记 2</title>
      <link href="/effective-python-study-note-2/"/>
      <url>/effective-python-study-note-2/</url>
      
        <content type="html"><![CDATA[<h4 id="用列表推导来取代map和filter"><a href="#用列表推导来取代map和filter" class="headerlink" title="用列表推导来取代map和filter"></a>用列表推导来取代map和filter</h4><pre><code>列表推导(list commprehension)：根据一份列表来制作另外一份列表</code></pre><pre class=" language-python"><code class="language-python">    <span class="token triple-quoted-string string">'''        用列表每个元素平方值构建另一份列表        a = [1, 2, 3, 4, 5, 6, 7, 8]    '''</span>    <span class="token comment" spellcheck="true"># 列表推导写法</span>    squares <span class="token operator">=</span> <span class="token punctuation">[</span>x <span class="token operator">**</span> <span class="token number">2</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> a<span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># map写法</span>    squares <span class="token operator">=</span> map<span class="token punctuation">(</span>lamda x<span class="token punctuation">:</span> x <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 条件输出</span>    <span class="token comment" spellcheck="true"># 列表推导输出偶数</span>    squares <span class="token operator">=</span> <span class="token punctuation">[</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> a <span class="token keyword">if</span> a<span class="token operator">%</span><span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># map辅以filter输出偶数</span>    squares <span class="token operator">=</span> map<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">,</span> filter<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><pre><code>    字典与集也有类似的推导机制，编写算法时，可以通过这些推导机制来创建衍生的数据结构。</code></pre><pre class=" language-python"><code class="language-python">    chile_ranks <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;'ghost': 1, 'god': 2, 'man': 3&amp;#125;</span>    rank_dict <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;rank: name for name,rank in chile_ranks.items()&amp;#125;</span>    chile_len_set <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;len(name) for name in rank_dict.values()&amp;#125;</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>rank_dict<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>chile_len_set<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#元组与dict互转</span>    tuple <span class="token operator">=</span> dict<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span>    dict <span class="token operator">=</span> tuple<span class="token punctuation">.</span>values</code></pre><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ol><li>不使用含有两个以上表达式的列表推导，难理解尽量避免</li><li>列表推导支持多级循环，每一级循环也支持多项条件</li></ol><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol><li>数据量较少时，不会出现问题，数据量较多时可能会耗费大量内存</li></ol><h4 id="用生成器表达式来改写数据量较大的列表推导"><a href="#用生成器表达式来改写数据量较大的列表推导" class="headerlink" title="用生成器表达式来改写数据量较大的列表推导"></a>用生成器表达式来改写数据量较大的列表推导</h4><h5 id="什么是生成器"><a href="#什么是生成器" class="headerlink" title="什么是生成器"></a>什么是生成器</h5><pre><code>    通过列表生成式，我们可以直接创建一个列表，但是，受到内存限制，列表容量肯定是有限的，而且创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。    所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间，在Python中，这种一边循环一边计算的机制，称为生成器：generator。</code></pre><pre class=" language-python"><code class="language-python">    <span class="token triple-quoted-string string">'''        eg. 读取日志文件    '''</span>    it <span class="token operator">=</span> <span class="token punctuation">(</span>len<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> open<span class="token punctuation">(</span><span class="token string">'/var/log.log'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>    <span class="token operator">>></span><span class="token operator">></span> <span class="token operator">&lt;</span>generator object <span class="token operator">&lt;</span>genexpr<span class="token operator">></span> at <span class="token number">0x101b81480</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>next<span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token operator">>></span><span class="token operator">></span> <span class="token string">"logs"</span></code></pre><h5 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h5><ol><li>当输入数据量较大时，列表推导可能会因为占用太多内存而出现问题</li><li>由生成器表达式返回的迭代器，可以逐次产生输出值，从而避免内存用量问题</li><li>把某个生成器表达式所返回的迭代器，放在另一个生成器表达式的for子表达式中，即可将二者结合起来</li></ol><pre class=" language-python"><code class="language-python">    a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span>    res <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> x <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> a<span class="token punctuation">)</span></code></pre><ol start="4"><li>串在一起的生成器表达式执行速度很快</li></ol><h4 id="尽量用enumerate取代range"><a href="#尽量用enumerate取代range" class="headerlink" title="尽量用enumerate取代range"></a>尽量用enumerate取代range</h4><pre class=" language-python"><code class="language-python">    <span class="token triple-quoted-string string">'''        场景说明：当想同时打印元素在列表中的索引和值的时候，使用range略显生硬    '''</span>    <span class="token comment" spellcheck="true"># range写法</span>    <span class="token keyword">for</span> i range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        value <span class="token operator">=</span> list<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        index <span class="token operator">=</span> i    <span class="token comment" spellcheck="true"># enumerate写法</span>    <span class="token keyword">for</span> i<span class="token punctuation">,</span> value <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%d: %s'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h5 id="要点-1"><a href="#要点-1" class="headerlink" title="要点"></a>要点</h5><ol><li>尽量使用enumerate来改写那种将range与下标访问结合的序列遍历代码</li><li>可以给enumerate提供第二个参数， 以指定开始计数时所用的值</li></ol><h4 id="用zip函数同时遍历两个迭代器"><a href="#用zip函数同时遍历两个迭代器" class="headerlink" title="用zip函数同时遍历两个迭代器"></a>用zip函数同时遍历两个迭代器</h4><pre><code>zip可以将两个或者多个迭代器封装成一个生成器</code></pre><pre class=" language-python"><code class="language-python">    <span class="token triple-quoted-string string">'''        场景说明：需要平行对两个列表进行操作时    '''</span>    names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'alice'</span><span class="token punctuation">,</span> <span class="token string">'bob'</span><span class="token punctuation">,</span> <span class="token string">'cendy'</span><span class="token punctuation">]</span>    letters <span class="token operator">=</span> <span class="token punctuation">[</span>len<span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token keyword">for</span> n <span class="token keyword">in</span> names<span class="token punctuation">]</span>    longest_name <span class="token operator">=</span> None    max_letters <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> name<span class="token punctuation">,</span> count <span class="token keyword">in</span> zip<span class="token punctuation">(</span>names<span class="token punctuation">,</span> letters<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> count <span class="token operator">></span> max_letters<span class="token punctuation">:</span>            longest_name <span class="token operator">=</span> name            max_letters <span class="token operator">=</span> count    <span class="token keyword">print</span><span class="token punctuation">(</span>longest_name<span class="token punctuation">)</span></code></pre><h5 id="要点-2"><a href="#要点-2" class="headerlink" title="要点"></a>要点</h5><ol><li>内置的zip函数可以平行地遍历多个迭代器</li><li>python3中的zip函数相当于生成器，会在遍历过程中产生元组</li><li>如果提供的迭代器长度不等，那么zip会自动提前终止</li><li>itertools内置模块中的zip_longest函数可以平行的遍历多个迭代器，而不用在乎他们的长度是否相等</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective Python 学习笔记 1</title>
      <link href="/effective-python-study-note-1/"/>
      <url>/effective-python-study-note-1/</url>
      
        <content type="html"><![CDATA[<h4 id="PEP-8规范"><a href="#PEP-8规范" class="headerlink" title="PEP 8规范"></a>PEP 8规范</h4><h5 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h5><ol><li>使用下标获取列表元素、调用函数或者给关键字参数赋值时，不在两旁加空格</li><li>函数、变量及属性应该用小写字母来拼写，个单词之间下划线相连</li><li>受保护实例属性以单个下划线开头：_protect_var</li><li>类与异常，以每个单词首字母大写形式命名：ClassName</li><li>模块级别的常量，采用全部大写字母方式命名，单词之间下划线连接：ALL_CAPS</li><li>类中实例方法（instance method），应该把首个参数命名为self，以表示该对象自身</li><li>类方法（class method）的首个参数应该命名为cls，以表示该类自身</li></ol><h5 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h5><ol><li>不要不要通过检测长度的办法（如 if len(somelist) &#x3D;&#x3D; 0）来判断somelist是否为[]或’’等空值，而是采用if not somelist这种写法来判断，它会假定：空值将自动评估为false</li><li>不要编写单行的if、for、while及except语句，应该分开书写以示清晰</li><li>import语句应总是放在开头</li><li>引入模块时，总是使用绝对名称，而不是根据当前面模块路径来使用相对名称：from bar import foo</li><li>如果一定要引用相对名称，采用from . import foo的格式</li><li>import语句应该按顺序划分成三个部分，分别表示标准库模块、第三方模块以及自用模块，在每个部分中import语句应该按照模块的字母顺序排列</li></ol><h4 id="bytes、str与unicode的区别"><a href="#bytes、str与unicode的区别" class="headerlink" title="bytes、str与unicode的区别"></a>bytes、str与unicode的区别</h4><ol><li><p>把Unicode字符转换成二进制数据就必须使用encode方法</p></li><li><p>把二进制数据字符转换成Unicode就必须使用decode方法</p></li><li><p>实现：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">to_str</span><span class="token punctuation">(</span>bytes_or_str<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> isinstance<span class="token punctuation">(</span>bytes_or_str<span class="token punctuation">,</span> bytes<span class="token punctuation">)</span><span class="token punctuation">:</span>        value <span class="token operator">=</span> bytes_or_str<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        value <span class="token operator">=</span> bytes_or_str    <span class="token keyword">return</span> value<span class="token keyword">def</span> <span class="token function">to_bytes</span><span class="token punctuation">(</span>str_to_bytes<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> isinstance<span class="token punctuation">(</span>str_to_bytes<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">:</span>        value <span class="token operator">=</span> str_to_bytes<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        value <span class="token operator">=</span> str_to_bytes    <span class="token keyword">return</span> value</code></pre></li><li><p>编写程序时，一定要把编码和解码操作放在界面外围来做。程序最核心的部分应该使用Unicode字符类型，而且不对编码做任何假设。这种方法既可以令程序接受多种类型的文本编码（如Latin-1、Shift JIS和Big 5），又可以保证输出的文本信息只采用一种编码形式（最好是UTF-8）</p></li><li><p>open函数添加了名为encoding的新参数，默认值为utf-8，这就要求再写入时必须传入unicode字符的str实例，而不接受二进制数据的bytes实例。解决方法：采用字符写入模式wb，读取采用rb，如：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'file.txt'</span><span class="token punctuation">,</span> <span class="token string">'wb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>os<span class="token punctuation">.</span>urandom<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre></li></ol><h4 id="用辅助函数取代复杂的表达式"><a href="#用辅助函数取代复杂的表达式" class="headerlink" title="用辅助函数取代复杂的表达式"></a>用辅助函数取代复杂的表达式</h4><pre><code>```python&#39;&#39;&#39;    eg. 需求：查询字符串&#39;&#39;&#39;from urllib.parse import parse_qs    my_values = parse_qs(&#39;red=5&amp;blue=0&amp;green=&#39;, keep_blank_values=True)    print(repr(my_values))&gt;&gt;&gt; &#123;&#39;red&#39;: [&#39;5&#39;], &#39;blue&#39;: [&#39;0&#39;], &#39;green&#39;: [&#39;&#39;]&#125;# 方法一：用get方法在my_values字典中查询不同参数print(&#39;RED:     &#39;, my_values.get(&#39;red&#39;))print(&#39;GREEN:   &#39;, my_values.get(&#39;green&#39;))&gt;&gt;&gt; RED:       [&#39;5&#39;]    GREEN:     [&#39;&#39;]     #无法将空值输出为0#方法二green = int(my_values.get(&#39;green&#39;, [])[0] or 0)print(&#39;GREEN:   %r&#39; % green)&gt;&gt;&gt; GREEN:   0  #表达式复杂，不易理解# 总结辅助函数def get_first_int(values, key, default=0):    found = values.get(key, [&#39;&#39;])    if found[0]:        found = found[0]    else:        found = default    return foundgreen = get_first_int(my_values, &#39;green&#39;)```</code></pre><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol><li>用if&#x2F;else表达式会比用or或and这样的Boolean操作符更清晰</li></ol><h4 id="了解切割序列的办法"><a href="#了解切割序列的办法" class="headerlink" title="了解切割序列的办法"></a>了解切割序列的办法</h4><h5 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h5><p>somelist[start:end]</p><ol><li>如果从头切片，将start留空，而非写0. end同理</li><li>在源列表进行切割之后，会产生一份全新的列表。系统依然维护着指向原列表中各个对象的引用。</li><li>在赋值时采用切割操作会改变原列表：a[2:7] &#x3D; [1, 2, 3]</li><li>单词切片操作内不要同时指定start、end和stride</li><li>反转字符串：re &#x3D; str[::-1]</li><li>第五条只对ASCII字符有效，对已经编码成utf-8字符串的Unicode字符无效</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows-pip-is-configured-with-locations-that-require-TLS-SSL</title>
      <link href="/windows-pip-is-configured-with-locations-that-require-TLS-SSL/"/>
      <url>/windows-pip-is-configured-with-locations-that-require-TLS-SSL/</url>
      
        <content type="html"><![CDATA[<h4 id="本机环境"><a href="#本机环境" class="headerlink" title="本机环境"></a>本机环境</h4><pre class=" language-bash"><code class="language-bash">Windows 10 64位Anaconda python 3.7</code></pre><h4 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h4><pre class=" language-python"><code class="language-python">pip <span class="token keyword">is</span> configured <span class="token keyword">with</span> locations that require TLS<span class="token operator">/</span>SSL<span class="token punctuation">,</span> however the ssl module <span class="token keyword">in</span> Python <span class="token keyword">is</span> <span class="token operator">not</span> available<span class="token punctuation">.</span></code></pre><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><h5 id="原因：Anaconda-环境变量未配置完全"><a href="#原因：Anaconda-环境变量未配置完全" class="headerlink" title="原因：Anaconda 环境变量未配置完全"></a><em>原因：Anaconda 环境变量未配置完全</em></h5><h5 id="需要配置的环境变量"><a href="#需要配置的环境变量" class="headerlink" title="需要配置的环境变量"></a>需要配置的环境变量</h5><pre class=" language-bash"><code class="language-bash">    D:\ProgramData\Anaconda3    D:\ProgramData\Anaconda3\Scripts    D:\ProgramData\Anaconda3\Library\bin</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> anaconda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h4 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h4><h5 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h5><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h5 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h5><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h5 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h5><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h5 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h5><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
