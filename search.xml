<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用nginx转发内网穿透服务端流量</title>
      <link href="/nat-traversal-with-nginx-docker-compose/"/>
      <url>/nat-traversal-with-nginx-docker-compose/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>目前手中有三台<code>NAT</code>后的设备，其中一台有内网穿透的需求，于是选择<code>frp</code>作为内网穿透工具，以便另外两台设备在外网访问。使用<code>nginx</code>对内网穿透的流量进行转发和过滤满足安全需求，使用<code>docker-compose</code>对<code>nginx</code>和<code>frp</code>服务进行编排。</p><p><a href="https://github.com/focuseds/NAT-traversal-server-with-nginx/">项目地址</a></p><h2 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h2><p>因为只有一台设备，所以拓扑结构非常简单，如下对内网服务器提供的<code>80</code>和<code>81</code>服务进行转发。</p><p><img src="https://raw.githubusercontent.com/focuseds/pics/main/img/202209-topological-structure-1" alt="拓扑结构"></p><h2 id="frp服务配置"><a href="#frp服务配置" class="headerlink" title="frp服务配置"></a>frp服务配置</h2><p>frp is a fast reverse proxy to help you expose a local server behind a NAT or firewall to the Internet. As of now, it supports TCP and UDP, as well as HTTP and HTTPS protocols, where requests can be forwarded to internal services by domain name.</p><p>frp 是一个专注于内网穿透的高性能的反向代理应用，支持 TCP、UDP、HTTP、HTTPS 等多种协议。可以将内网服务以安全、便捷的方式通过具有公网 IP 节点的中转暴露到公网。</p><h3 id="frp服务端"><a href="#frp服务端" class="headerlink" title="frp服务端"></a>frp服务端</h3><p>根据官方文档，可以通过配置<code>frps.ini</code>对服务端进行配置，比如服务端口和身份认证，下面是可以参考的基础配置。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">token</span> = c4bf92d681</span><br></pre></td></tr></table></figure><p>上面配置文件的<code>common</code>块中配置了最基础的服务端口和认证口令，认证口令可以防止服务被恶意使用。还有更多地配置项可以参考<a href="https://github.com/fatedier/frp">frp文档</a>。</p><h3 id="frpc"><a href="#frpc" class="headerlink" title="frpc"></a>frpc</h3><p>根据我们的拓扑和服务端配置，公网转发服务器IP为<code>103.12.35.6</code>，故客户端配置文件可配置如下。客户端的配置文件<code>frpc.ini</code>分为两部分：服务端信息和需要转发的端口信息。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> =  <span class="number">103.12</span>.<span class="number">35.6</span> <span class="comment">#服务器地址</span></span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">token</span> = c4bf92d681</span><br><span class="line"></span><br><span class="line"><span class="section">[tcp_80]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">80</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="section">[tcp_81]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">81</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">8081</span></span><br></pre></td></tr></table></figure><p>需要修改<code>server_addr</code>为远程<code>frps</code>服务器的IP地址，<code>local_port</code>是<code>NAT</code>设备Web服务的端口，<code>remote_port</code>是映射在服务器上的端口。以上的配置文件只演示了<code>tcp</code>服务的穿透，可以根据自己的需求配置。比如对<code>ssh</code>端口进行转发。<a href="https://github.com/fatedier/frp#access-your-computer-in-lan-by-ssh">这里</a>是官方提供的例子。</p><h3 id="安全需求"><a href="#安全需求" class="headerlink" title="安全需求"></a>安全需求</h3><p><code>frp</code>提供了两种客户端认证方式：<code>Token认证</code>和<code>OIDC认证</code>。</p><h4 id="Token认证"><a href="#Token认证" class="headerlink" title="Token认证"></a>Token认证</h4><p>在上面的配置中，使用的就是Token认证，需要在服务端和客户端的配置文件下的<code>common</code>块中配置<code>token = *密钥*</code>即可。</p><h4 id="OIDC认证"><a href="#OIDC认证" class="headerlink" title="OIDC认证"></a>OIDC认证</h4><p>使用<code>OIDC认证</code>需要在服务端和客户端的配置文件下的<code>common</code>块中指定认证方式为<code>oidc</code>。</p><h5 id="frps配置文件参考"><a href="#frps配置文件参考" class="headerlink" title="frps配置文件参考"></a>frps配置文件参考</h5><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">authentication_method</span> = oidc</span><br><span class="line"><span class="attr">oidc_issuer</span> = https://example-oidc-issuer.com/</span><br><span class="line"><span class="attr">oidc_audience</span> = https://oidc-audience.com/.default</span><br></pre></td></tr></table></figure><h5 id="frpc配置文件参考"><a href="#frpc配置文件参考" class="headerlink" title="frpc配置文件参考"></a>frpc配置文件参考</h5><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">authentication_method</span> = oidc</span><br><span class="line"><span class="attr">oidc_client_id</span> = <span class="number">98692467</span>-<span class="number">37</span>de-<span class="number">409</span>a-<span class="number">9</span>fac-bb2585826f18 <span class="comment"># Replace with OIDC client ID</span></span><br><span class="line"><span class="attr">oidc_client_secret</span> = oidc_secret</span><br><span class="line"><span class="attr">oidc_audience</span> = https://oidc-audience.com/.default</span><br><span class="line"><span class="attr">oidc_token_endpoint_url</span> = https://example-oidc-endpoint.com/oauth2/v2.<span class="number">0</span>/token</span><br></pre></td></tr></table></figure><h5 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h5><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>authentication_method</td><td>身份验证方式，token 或 oidc，默认为 token。</td></tr><tr><td>authenticate_heartbeats</td><td>在每一个心跳包中附加上身份认证信息，客户端服务端需要一致。</td></tr><tr><td>authenticate_new_work_conns</td><td>在每次创建工作连接时附加上身份认证信息，客户端服务端需要一致。</td></tr></tbody></table><h3 id="frp下载"><a href="#frp下载" class="headerlink" title="frp下载"></a>frp下载</h3><p>可以到<code>frp</code><a href="https://github.com/fatedier/frp/releases/">版本发布页下载</a>，选择并下载适合自己平台的版本。在下载的压缩包中包含了服务端和客户端的所有文件，以<code>linux_amd64</code>为例，目录结构为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── LICENSE</span><br><span class="line">├── frpc</span><br><span class="line">├── frpc.ini</span><br><span class="line">├── frpc_full.ini</span><br><span class="line">├── frps</span><br><span class="line">├── frps.ini</span><br><span class="line">└── frps_full.ini</span><br></pre></td></tr></table></figure><h2 id="容器编排"><a href="#容器编排" class="headerlink" title="容器编排"></a>容器编排</h2><p>本节使用<code>docker-compose</code>编排<code>frps</code>和<code>nginx</code>，完成对流量的转发和过滤。</p><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── docker-compose.yml</span><br><span class="line">├── frps</span><br><span class="line">│   ├── Dockerfile</span><br><span class="line">│   └── conf</span><br><span class="line">│       └── frps.ini</span><br><span class="line">├── nginx</span><br><span class="line">│   ├── Dockerfile</span><br><span class="line">│   ├── conf</span><br><span class="line">│   │   ├── firewall_conf</span><br><span class="line">│   │   │   └── firewall.conf</span><br><span class="line">│   │   ├── nginx.conf</span><br><span class="line">│   │   └── tcp_conf</span><br><span class="line">│   │       ├── tcp80.conf</span><br><span class="line">│   │       └── tcp81.conf</span><br><span class="line">│   ├── logs</span><br><span class="line">│   └── templates</span><br><span class="line">│       └── index.html</span><br></pre></td></tr></table></figure><h3 id="docker-compose编排文件"><a href="#docker-compose编排文件" class="headerlink" title="docker-compose编排文件"></a>docker-compose编排文件</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.5&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">frps_app:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">frps_server</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./frps/conf:/etc/frp</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./frps</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">nginx_app:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./nginx</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nginx/logs:/var/nginx/logs</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;7000:7000&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8081:8081&quot;</span></span><br></pre></td></tr></table></figure><h3 id="frps容器配置"><a href="#frps容器配置" class="headerlink" title="frps容器配置"></a>frps容器配置</h3><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p>在<code>Dockerfile</code>中配置<code>frps</code>镜像，<code>conf/</code>文件夹中放置配置文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">frps/</span><br><span class="line">├── Dockerfile</span><br><span class="line">└── conf</span><br><span class="line">    └── frps.ini</span><br></pre></td></tr></table></figure><h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> snowdreamtech/frps</span><br></pre></td></tr></table></figure><h3 id="nginx容器配置"><a href="#nginx容器配置" class="headerlink" title="nginx容器配置"></a>nginx容器配置</h3><p>Nginx是一款轻量级的Web服务器、反向代理服务器，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。</p><h4 id="目录结构-1"><a href="#目录结构-1" class="headerlink" title="目录结构"></a>目录结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">nginx/</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── conf</span><br><span class="line">│   ├── firewall_conf</span><br><span class="line">│   │   └── firewall.conf</span><br><span class="line">│   ├── nginx.conf</span><br><span class="line">│   └── tcp_conf</span><br><span class="line">│       ├── tcp7000.conf</span><br><span class="line">│       ├── tcp80.conf</span><br><span class="line">│       └── tcp81.conf</span><br><span class="line">├── logs</span><br><span class="line">└── templates</span><br><span class="line">    └── index.html</span><br></pre></td></tr></table></figure><p><code>nginx</code>这本文场景中除了对流量进行转发，还在<code>80</code>端口提供了<code>html</code>服务。在<code>conf/</code>文件夹中放置了流量过滤和转发的配置文件，流量过滤目前只对国外流量进行了过滤。</p><h4 id="编排后的网络拓扑"><a href="#编排后的网络拓扑" class="headerlink" title="编排后的网络拓扑"></a>编排后的网络拓扑</h4><p>下图是经过容器编排后的网络拓扑结构。</p><p><img src="https://raw.githubusercontent.com/focuseds/pics/main/img/202209-topological-structure-with-docker-compose.png" alt="容器编排后的拓扑结构"></p><p>其中<code>172.13.0.0/24</code>段是<code>frps</code>和<code>nginx</code>两个容器所在网段。通过<code>docker-compose</code>端口映射将通过<code>nginx</code>转发的<code>frps</code>服务端口和内网服务器映射到该服务器上的两个内网端口映射到拥有独立IP的云主机上。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ports:</span><br><span class="line">    - <span class="string">&quot;7000:7000&quot;</span></span><br><span class="line">    - <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">    - <span class="string">&quot;8081:8081&quot;</span></span><br></pre></td></tr></table></figure><h4 id="nginx配置文件"><a href="#nginx配置文件" class="headerlink" title="nginx配置文件"></a>nginx配置文件</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">worker_processes</span> auto;</span><br><span class="line"> </span><br><span class="line"><span class="section">events</span> &#123; <span class="attribute">worker_connections</span> <span class="number">1024</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="section">stream</span> &#123;</span><br><span class="line">        <span class="attribute">log_format</span> proxy <span class="string">&#x27;<span class="variable">$remote_addr</span> [<span class="variable">$time_local</span>] &#x27;</span></span><br><span class="line">                    <span class="string">&#x27;<span class="variable">$protocol</span> <span class="variable">$status</span> <span class="variable">$bytes_sent</span> <span class="variable">$bytes_received</span> &#x27;</span></span><br><span class="line">                    <span class="string">&#x27;<span class="variable">$session_time</span> &quot;<span class="variable">$upstream_addr</span>&quot; &#x27;</span></span><br><span class="line">                    <span class="string">&#x27;&quot;<span class="variable">$upstream_bytes_sent</span>&quot; &quot;<span class="variable">$upstream_bytes_received</span>&quot; &quot;<span class="variable">$upstream_connect_time</span>&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">access_log</span> /var/nginx/logs/tcp-access.log proxy ;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">open_log_file_cache</span> <span class="literal">off</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 转发frps流量</span></span><br><span class="line">        <span class="attribute">include</span> tcp_conf/<span class="regexp">*.conf</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nopush</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">autoindex</span>    <span class="literal">off</span>;</span><br><span class="line">    <span class="attribute">server_tokens</span>  <span class="literal">off</span>;</span><br><span class="line">    <span class="attribute">gzip</span><span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">gzip_min_length</span> <span class="number">1k</span>;</span><br><span class="line">    <span class="attribute">gzip_buffers</span> <span class="number">4</span> <span class="number">16k</span>;</span><br><span class="line">    <span class="attribute">gzip_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">    <span class="attribute">gzip_comp_level</span> <span class="number">4</span>;</span><br><span class="line">    <span class="attribute">gzip_types</span> text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对国外流量进行过滤</span></span><br><span class="line"><span class="attribute">include</span> firewall_conf/firewall.conf;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> localhost;</span><br><span class="line">        <span class="attribute">access_log</span> /var/nginx/logs/access-<span class="number">80</span>.log;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 过滤可能的爬虫客户端</span></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$http_user_agent</span> <span class="regexp">~* wget|curl|scrapy|okhttp|httpclient|java|python|go)</span> &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">444</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="attribute">root</span>   /var/www/static;</span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    <span class="attribute">add_header</span> X-XSS-Protection <span class="string">&#x27;1; mode=block&#x27;</span>;</span><br><span class="line">    <span class="attribute">limit_except</span> GET &#123; <span class="attribute">deny</span> all; &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="upstream配置"><a href="#upstream配置" class="headerlink" title="upstream配置"></a>upstream配置</h3><p>在<code>nginx</code>的配置文件目录下新建<code>tcp_conf/</code>，并编写需要配置的<code>80</code>和<code>81</code>的配置文件。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frps7000端口tcp转发</span></span><br><span class="line"><span class="section">upstream</span> tcp7000 &#123;</span><br><span class="line">    <span class="attribute">server</span> frps_app:<span class="number">7000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">7000</span>;</span><br><span class="line">    <span class="attribute">proxy_connect_timeout</span> <span class="number">8s</span>;</span><br><span class="line">    <span class="attribute">proxy_timeout</span> <span class="number">24h</span>;</span><br><span class="line">    <span class="attribute">proxy_pass</span> tcp7000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 8080端口tcp转发</span></span><br><span class="line"><span class="section">upstream</span> tcp8080 &#123;</span><br><span class="line">    <span class="attribute">server</span> frps_app:<span class="number">8080</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line">    <span class="attribute">proxy_connect_timeout</span> <span class="number">8s</span>;</span><br><span class="line">    <span class="attribute">proxy_timeout</span> <span class="number">24h</span>;</span><br><span class="line">    <span class="attribute">proxy_pass</span> tcp8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 81端口tcp转发</span></span><br><span class="line"><span class="section">upstream</span> tcp8081 &#123;</span><br><span class="line">    <span class="attribute">server</span> frps_app:<span class="number">8081</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8081</span>;</span><br><span class="line">    <span class="attribute">proxy_connect_timeout</span> <span class="number">8s</span>;</span><br><span class="line">    <span class="attribute">proxy_timeout</span> <span class="number">24h</span>;</span><br><span class="line">    <span class="attribute">proxy_pass</span> tcp8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dockerfile-1"><a href="#Dockerfile-1" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> TimeZone=Asia/Shanghai</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /etc/nginx/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cp</span> nginx.conf ./nginx.conf.bak</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./conf/nginx.conf ./</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">mkdir</span> tcp_conf</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">mkdir</span> firewall_conf</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./conf/tcp_conf/* ./tcp_conf/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./conf/firewall_conf/* ./firewall_conf/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">mkdir</span> -p /var/www/static</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /var/www/static</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./templates/index.html ./index.html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">7000</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>项目写的比较潦草，希望都偶大家交流，感谢。</p><p><img src="https://raw.githubusercontent.com/focuseds/pics/main/img/nat-project-running-example.png" alt="运行截图"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://github.com/fatedier/frp">frp文档</a></li><li><a href="https://github.com/focuseds/NAT-traversal-server-with-nginx/">项目地址</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> docker </tag>
            
            <tag> 内网穿透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP简答汇总</title>
      <link href="/yuque/CPP%E7%AE%80%E7%AD%94%E6%B1%87%E6%80%BB/"/>
      <url>/yuque/CPP%E7%AE%80%E7%AD%94%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="CPP-简答汇总"><a href="#CPP-简答汇总" class="headerlink" title="CPP 简答汇总"></a>CPP 简答汇总</h1><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><ol><li>面向对象的编程语言有哪些特点？</li></ol><p><strong>解：</strong>面向对象的编程语言与以往各种编程语言有根本的不同，它设计的出发点就是为了能更直接的描述客观世界中存在的事物以及它们之间的关系。面向对象的编程语言将客观事物看作具有属性和行为的对象，通过抽象找出同一类对象的共同属性（静态特征）和行为（动态特征），形成类。通过类的继承与多态可以很方便地实现代码重用，大大缩短了软件开发周期，并使得软件风格统一。因此，面向对象的编程语言使程序能够比较直接地反问题域的本来面目，软件开发人员能够利用人类认识事物所采用的一般思维方法来进行软件开发。C++语言是目前应用最广的面向对象的编程语言。</p><ol><li>什么是对象？什么是面向对象方法？这种方法有哪些特点？</li></ol><p><strong>解：</strong>从一般意义上讲，对象是现实世界中一个实际存在的事物，它可以是有形的，也可以是无形的。对象是构成世界的一个独立单位，它具有自己的静态特征和动态特征。面向对象方法中的对象，是系统中用来描述客观事物的一个实体，它是用来构成系统的一个基本单位，由一组属性和一组行为构成。<br>面向对象的方法将数据及对数据的操作方法放在一起，作为一个相互依存、不可分离的整体——对象。对同类型对象抽象出其共性，形成类。类中的大多数数据，只能用本类的方法进行处理。类通过一个简单的外部接口，与外界发生关系，对象与对象之间通过消息进行通讯。这样，程序模块间的关系更为简单，程序模块的独立性、数据的安全性就有了良好的保障。通过实现继承与多态性，还可以大大提高程序的可重用性，使得软件的开发和维护都更为方便。<br>面向对象方法所强调的基本原则，就是直接面对客观存在的事物来进行软件开发，将人们在日常生活中习惯的思维方式和表达方式应用在软件开发中，使软件开发从过分专业化的方法、规则和技巧中回到客观世界，回到人们通常的思维。</p><ol><li>什么叫做封装？</li></ol><p><strong>解：</strong>封装是面向对象方法的一个重要原则，就是把对象的属性和服务结合成一个独立的系统单位，并尽可能隐蔽对象的内部细节。</p><ol><li>面向对象的软件工程包括哪些主要内容？</li></ol><p><strong>解：</strong>面向对象的软件工程是面向对象方法在软件工程领域的全面应用，它包括面向对象的分析（OOA）、面向对象的设计（OOD）、面向对象的编程（OOP）、面向对象的测试（OOT）和面向对象的软件维护（OOSM）等主要内容。</p><h2 id="CPP-简单程序设计"><a href="#CPP-简单程序设计" class="headerlink" title="CPP 简单程序设计"></a>CPP 简单程序设计</h2><ol><li>使用关键字 const 而不是#define 语句的好处有哪些？</li></ol><p><strong>解：</strong>const 定义的常量是有类型的，所以在使用它们时编译器可以查错；而且，这些变量在调试时仍然是可见的。</p><ol><li>什么叫做表达式？</li></ol><p><strong>解：</strong>任何一个计算值的公示都叫表达式。</p><ol><li>变量有哪几种存储类型？</li></ol><p><strong>解：</strong>变量有以下几种存储类型：<br>auto 存储类型：采用堆栈方式分配内存空间，属于一时性存储，其存储空间可以被若干变量多次覆盖使用；<br>register 存储类型：存放在通用寄存器中；<br>extern 存储类型：在所有函数和程序段中都可引用；<br>static 存储类型：在内存中是以固定地址存放的，在整个程序运行期间都有效。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ol><li>C++中的函数是什么？什么叫主调函数，什么叫被调函数，二者之间有什么关系？如何调用一个函数？</li></ol><p><strong>解：</strong> 一个较为复杂的系统往往需要划分为若干子系统，高级语言中的子程序就是用来实现这种模块划分的。C 和 C++语言中的子程序就体现为函数。调用其它函数的函数被称为主调函数，被其它函数调用的函数称为被调函数。一个函数很可能既调用别的函数又被另外的函数调用，这样它可能在某一个调用与被调用关系中充当主调函数，而在另一个调用与被调用关系中充当被调函数。调用函数之前先要声明函数原型。按如下形式声明：类型标识符 被调函数名 (含类型说明的形参表);声明了函数原型之后，便可以按如下形式调用子函数：函数名（实参列表）</p><ol><li>比较值调用和引用调用的相同点与不同点。</li></ol><p><strong>解：</strong>值调用是指当发生函数调用时，给形参分配内存空间，并用实参来初始化形参（直接将实参的值传递给形参）。这一过程是参数值的单向传递过程，一旦形参获得了值便与实参脱离关系，此后无论形参发生了怎样的改变，都不会影响到实参。<br>引用调用将引用作为形参，在执行主调函数中的调用语句时，系统自动用实参来初始化形参。这样形参就成为实参的一个别名，对形参的任何操作也就直接作用于实参。</p><ol><li>什么叫内联函数?它有哪些特点？</li></ol><p><strong>解：</strong>定义时使用关键字 inline 的函数叫做内联函数；编译器在编译时在调用处用函数体进行替换,节省了参数传递、控制转移等开销；内联函数体内不能有循环语句和 switch 语句；内联函数的定义必须出现在内联函数第一次被调用之前；对内联函数不能进行异常接口声明；</p><ol><li>函数原型中的参数名与函数定义中的参数名以及函数调用中的参数名必须一致吗</li></ol><p><strong>解：</strong>不必一致，所有的参数是根据位置和类型而不是名字来区分的。</p><ol><li>重载函数时通过什么来区分？</li></ol><p><strong>解：</strong>重载的函数的函数名是相同的，但它们的参数的个数和数据类型不同，编译器根据实参和形参的类型及个数的最佳匹配，自动确定调用哪一个函数。</p><ol><li>什么叫作嵌套调用？什么叫作递归调用？</li></ol><p><strong>解：</strong>函数允许嵌套调用，如果函数 1 调用了函数 2，函数 2 再调用函数 3，便形成了函数的嵌套调用。函数可以直接或间接地调用自身，称为递归调用。</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ol><li>解释 public 和 private 的作用，公有类型成员与私有类型成员有些什么区别？</li></ol><p><strong>解：</strong>公有类型成员用 public 关键字声明，公有类型定义了类的外部接口；私有类型的成员用 private 关键字声明，只允许本类的函数成员来访问，而类外部的任何访问都是非法的，这样，私有的成员就整个隐蔽在类中，在类的外部根本就无法看到，实现了访问权限的有效控制。</p><ol><li>protected 关键字有何作用？</li></ol><p><strong>解：</strong>protected 用来声明保护类型的成员，保护类型的性质和私有类型的性质相似，其差别在于继承和派生时派生类的成员函数可以访问基类的保护成员。</p><ol><li>构造函数和析构函数有什么作用？</li></ol><p><strong>解：</strong>构造函数的作用就是在对象被创建时利用特定的值构造对象，将对象初始化为一个特定的状态，使此对象具有区别于彼对象的特征，完成的就是是一个从一般到具体的过程，构造函数在对象创建的时候由系统自动调用。<br>析构函数与构造函数的作用几乎正好相反，它是用来完成对象被删除前的一些清理工作，也就是专门作扫尾工作的。一般情况下，析构函数是在对象的生存期即将结束的时刻由系统自动调用的，它的调用完成之后，对象也就消失了，相应的内存空间也被释放。</p><ol><li>数据成员可以为公有的吗？成员函数可以为私有的吗？</li></ol><p><strong>解：</strong>可以，二者都是合法的。数据成员和成员函数都可以为公有或私有的。但数据成员最好定义为私有的。</p><ol><li>已知 class A 中有数据成员 int a，如果定义了 A 的两个对象 A1、A2，它们各自的数据成员 a 的值可以不同吗？</li></ol><p><strong>解：</strong>可以，类的每一个对象都有自己的数据成员。</p><ol><li>什么叫做拷贝构造函数？拷贝构造函数何时被调用？</li></ol><p><strong>解：</strong>拷贝构造函数是一种特殊的构造函数，具有一般构造函数的所有特性，其形参是本类的对象的引用，其作用是使用一个已经存在的对象，去初始化一个新的同类的对象。在以下三种情况下会被调用：在当用类的一个对象去初始化该类的另一个对象时；如果函数的形参是类对象，调用函数进行形参和实参结合时；如果函数的返回值是类对象，函数调用完成返回时；</p><ol><li>拷贝构造函数与赋值运算符(&#x3D;)有何不同？</li></ol><p><strong>解：</strong>赋值运算符(&#x3D;)作用于一个已存在的对象；而拷贝构造函数会创建一个新的对象。</p><h2 id="数据的共享与保护"><a href="#数据的共享与保护" class="headerlink" title="数据的共享与保护"></a>数据的共享与保护</h2><ol><li>什么叫做作用域？有哪几种类型的作用域？</li></ol><p><strong>解：</strong>作用域讨论的是标识符的有效范围，作用域是一个标识符在程序正文中有效的区域。C++的作用域分为函数原形作用域、块作用域(局部作用域)、类作用域和文件作用域.</p><ol><li>什么叫做可见性？可见性的一般规则是什么？</li></ol><p><strong>解：</strong>可见性是标识符是否可以引用的问题；可见性的一般规则是：标识符要声明在前，引用在后，在同一作用域中，不能声明同名的标识符。对于在不同的作用域声明的标识符，遵循的原则是：若有两个或多个具有包含关系的作用域，外层声明的标识符如果在内层没有声明同名标识符时仍可见，如果内层声明了同名标识符则外层标识符不可见。</p><ol><li>什么叫做静态数据成员？它有何特点？</li></ol><p><strong>解：</strong>类的静态数据成员是类的数据成员的一种特例，采用 static 关键字来声明。对于类的普通数据成员，每一个类的对象都拥有一个拷贝，就是说每个对象的同名数据成员可以分别存储不同的数值，这也是保证对象拥有自身区别于其它对象的特征的需要，但是静态数据成员，每个类只要一个拷贝，由所有该类的对象共同维护和使用，这个共同维护、使用也就实现了同一类的不同对象之间的数据共享。</p><ol><li>什么叫做静态函数成员？它有何特点？</li></ol><p><strong>解：</strong>使用 static 关键字声明的函数成员是静态的，静态函数成员属于整个类，同一个类的所有对象共同维护，为这些对象所共享。静态函数成员具有以下两个方面的好处，一是由于静态成员函数只能直接访问同一个类的静态数据成员，可以保证不会对该类的其余数据成员造成负面影响；二是同一个类只维护一个静态函数成员的拷贝，节约了系统的开销，提高程序的运行效率。</p><ol><li>什么叫做友元函数？什么叫做友元类？</li></ol><p><strong>解：</strong>友元函数是使用 friend 关键字声明的函数，它可以访问相应类的保护成员和私有成员。友元类是使用 friend 关键字声明的类，它的所有成员函数都是相应类的友元函数。</p><ol><li>如果类 A 是类 B 的友元，类 B 是类 C 的友元，类 D 是类 A 的派生类，那么类 B 是类 A 的友元吗？类 C 是类 A 的友元吗？类 D 是类 B 的友元吗？</li></ol><p><strong>解：</strong>类 B 不是类 A 的友元，友元关系不具有交换性；<br>类 C 不是类 A 的友元，友元关系不具有传递性；<br>类 D 不是类 B 的友元，友元关系不能被继承。</p><ol><li>静态成员变量可以为私有的吗？声明一个私有的静态整型成员变量。</li></ol><p><strong>解：</strong>可以，例如：<br>private:<br>static int a;</p><ol><li>如果在类模板的定义中有一个静态数据成员，则在程序运行中会产生多少个相应的静态变量？</li></ol><p><strong>解：</strong>这个类模板的每一个实例类都会产生一个相应的静态变量。</p><ol><li>在函数内部定义的普通局部变量和静态局部变量在功能上有何不同？计算机底层对这两类变量做了怎样不同的处理，导致了这种差异？</li></ol><p><strong>解：</strong>静态变量：程序级别的变量，生命周期是整个程序，在程序结束后释放；<br>普通变量：作用域为当前函数，当前会话，或者当前文件，离开后自动释放；<br>全局变量：作用于整个工程，自动分配；<br>静态局部变量：静态局部变量只在定义的函数内有效，程序只分配一次内存，函数返回后，该变量值不会变化。<br>静态函数：静态函数只能在本文件中使用，是文件的内部函数；<br>普通函数：普通函数则是为整个工程，要实现外部调用添加 extern 即可；</p><p>全局变量、静态全局变量和静态局部变量都存放在内存的静态存储区域；<br>局部变量存放在内存的栈区。</p><p>栈：由系统自动分配，速度较快。但程序员是无法控制的,栈获得的空间较小；<br>堆：是由 malloc，new 分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。</p><h2 id="数组、指针与字符串"><a href="#数组、指针与字符串" class="headerlink" title="数组、指针与字符串"></a>数组、指针与字符串</h2><ol><li>运算符*和&amp;的作用是什么？</li></ol><p>**解：***称为指针运算符，是一个一元操作符，表示指针所指向的对象的值；&amp;称为取地址运算符，也是一个一元操作符，是用来得到一个对象的地址。</p><ol><li>什么叫做指针？指针中储存的地址和这个地址中的值有何区别？</li></ol><p><strong>解：</strong>指针是一种数据类型，具有指针类型的变量称为指针变量。指针变量存放的是另外一个对象的地址，这个地址中的值就是另一个对象的内容。</p><ol><li>在字符串”Hello，world!”中结束符是什么？</li></ol><p><strong>解：</strong>是 NULL 字符。</p><ol><li>引用和指针有何区别？何时只能使用指针而不能使用引用？</li></ol><p>解： 引用是一个别名，不能为 NULL 值，不能被重新分配；指针是一个存放地址的变量。当需要对变量重新赋以另外的地址或赋值为 NULL 时只能使用指针。</p><h2 id="继承与派生"><a href="#继承与派生" class="headerlink" title="继承与派生"></a>继承与派生</h2><ol><li>比较类的三种继承方式 public 公有继承、protected 保护继承、private 私有继承之间的差别。</li></ol><p><strong>解：</strong>不同的继承方式，导致不同访问属性的基类成员在派生类中的访问属性也有所不同：<br>公有继承，使得基类 public(公有)和 protected(保护)成员的访问属性在派生类中不变，而基类 private(私有)成员不可访问。<br>私有继承，使得基类 public(公有)和 protected(保护)成员都以 private(私有)成员身份出现在派生类中，而基类 private(私有)成员不可访问。<br>保护继承中，基类 public(公有)和 protected(保护)成员都以 protected(保护)成员身份出现在派生类中，而基类 private(私有)成员不可访问。</p><ol><li>派生类构造函数执行的次序是怎样的？</li></ol><p><strong>解：</strong>派生类构造函数执行的一般次序为：调用基类构造函数；调用成员对象的构造函数；派生类的构造函数体中的内容。</p><ol><li>什么叫做虚基类？有何作用？</li></ol><p><strong>解：</strong>当某类的部分或全部直接基类是从另一个基类派生而来，这些直接基类中，从上一级基类继承来的成员就拥有相同的名称，派生类的对象的这些同名成员在内存中同时拥有多个拷贝，我们可以使用作用域分辨符来唯一标识并分别访问它们。我们也可以将直接基类的共同基类设置为虚基类，这时从不同的路径继承过来的该类成员在内存中只拥有一个拷贝，这样就解决了同名成员的唯一标识问题。<br>虚基类的声明是在派生类的定义过程，其语法格式为：<br>class 派生类名：virtual 继承方式 基类名<br>上述语句声明基类为派生类的虚基类，在多继承情况下，虚基类关键字的作用范围和继承方式关键字相同，只对紧跟其后的基类起作用。声明了虚基类之后，虚基类的成员在进一步派生过程中，和派生类一起维护一个内存数据拷贝。</p><ol><li>组合与继承有什么共同点和差异？通过组合生成的类与被组合的类之间的逻辑关系是什么？继承呢？</li></ol><p><strong>解：</strong>组合和继承的共同点：继承和组合的使用都可以减少重复代码，同时若类 B 是类 A 的内嵌对象，则 B 类具有 A 类的全部数据。<br>不同点：组合是通过在其他类中定义对象来使用类中的方法和属性，不能访问父类的任何接口。而继承则是从父类中得到方法和属性，即可以得到父类的全部接口，并加以调用。<br>通过组合生成的类和被组合的类之间的逻辑关系：组合生成的类具有被组合类的全部内容，但是并不包括被组合类的全部接口，就是通过被组合的类的对象只能访问组合类的成员函数，但不能直接访问到被组合类的成员函数。<br>继承类与基类的逻辑关系：即通过派生类的对象不但可以访问派生类的成员函数，也能访问基类的成员函数，派生类是可以完全继承基类的任何内容的包括全部接口。</p><ol><li>基类与派生类的对象、指针及引用之间，哪些情况下可以隐含转换，哪些情况可以显示转换？在涉及多重继承或虚拟继承的情况下，在转换时会面临哪些新问题？</li></ol><p><strong>解：</strong>派生类指针可以隐含转换为基类指针，之所以允许这种隐含转换发生，是因为它是安全的转换。例如：Base _ pb&#x3D;new Derived; &#x2F;&#x2F;将 Derived 指针隐式转换为 Base 指针。Derived _ pb&#x3D;static_cast&lt;Derived*&gt; (pb); &#x2F;&#x2F;将 Base 指针显示转换为 Derived 指针。<br>基类指针可以指向任何派生类对象，因此基类指针和派生类指针具有一般和特殊的关系。C++对这两种关系的处理方式是：从特殊的指针转换到一般的指针是安全的，因此允许隐含转换；从一般的指针转换到特殊的指针是不安全的，因此只能显示的转换。续：P301</p><h2 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h2><ol><li>什么叫做多态性 ?在 C++中是如何实现多态的？</li></ol><p><strong>解：</strong>多态是指同样的消息被不同类型的对象接收时导致完全不同的行为，是对类的特定成员函数的再抽象。C++支持的多态有多种类型，重载(包括函数重载和运算符重载)和虚函数是其中主要的方式。</p><ol><li>什么叫做抽象类？抽象类有何作用？抽象类的派生类是否一定要给出纯虚函数的实现？</li></ol><p><strong>解：</strong>带有纯虚函数的类是抽象类。抽象类的主要作用是通过它为一个类族建立一个公共的接口，使它们能够更有效地发挥多态特性。抽象类声明了一组派生类共同操作接口的通用语义，而接口的完整实现，即纯虚函数的函数体，要由派生类自己给出。但抽象类的派生类并非一定要给出纯虚函数的实现，如果派生类没有给出纯虚函数的实现，这个派生类仍然是一个抽象类。</p><ol><li>在 C++中，能否声明虚构造函数？为什么？能否声明虚析构函数？有何用途？</li></ol><p><strong>解：</strong>在 C++中，不能声明虚构造函数，多态是不同的对象对同一消息有不同的行为特性，虚函数作为运行过程中多态的基础，主要是针对对象的，而构造函数是在对象产生之前运行的，因此虚构造函数是没有意义的；可以声明虚析构函数，析构函数的功能是在该类对象消亡之前进行一些必要的清理工作，如果一个类的析构函数是虚函数，那么，由它派生而来的所有子类的析构函数也是虚函数。析构函数设置为虚函数之后，在使用指针引用时可以动态联编，实现运行时的多态，保证使用基类的指针就能够调用适当的析构函数针对不同的对象进行清理工作。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CPP学习笔记</title>
      <link href="/yuque/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/yuque/CPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><ol><li>C++支持的程序设计方法<ol><li>面向过程的程序设计方法</li><li>面向对象的程序设计方法</li><li>范型程序设计方法</li></ol></li><li>软件 &#x3D; 程序 + 文档</li><li>面向对象的语言<ol><li>问题域：一个软件所要解决的问题，这些问题所涉及的业务范围称为该软件的问题域</li><li>面向对象的编程语言将客观事物看作具有属性和行为（或服务）的对象，通过<strong>抽象</strong>找出同一类对象的<strong>共同属性</strong>（静态特征）和<strong>行为</strong>（动态特征），形成<strong>类</strong>。</li></ol></li><li>面向对象方法的由来<ol><li>结构化程序设计思想：自顶向下、逐步求精；按功能划分为若干基本模块，这些模块形成一个树状结构；每个模块内部均是由顺序、选择和循环 3 种基本机构组成；其模块化实现的具体方法是子程序。</li><li>面向对象方法：首先，它将数据及对数据的操作方法放在一起，作为一个相互依存、不可分割的整体——对象。对同类型对象抽象出其共性，形成类。类中的大多数数据，只能用本类的方法进行处理，类通过一个简单的外部接口与外界发生关系，对象与对象之间通过消息进行通信。</li></ol></li><li>面向对象的基本概念<ol><li>对象——是系统中用来描述客观事物的一个实体，它是用来构成系统的一个基本单位。对象由一组属性和一组行为构成；</li><li>类——分类的依据是抽象；它是具有相同属性和服务的一组对象的集合；</li><li>封装——是面向对象中的一个重要原则，就是把对象的属性和服务结合成一个独立的系统单位，并尽可能隐蔽对象的内部细节；</li><li>继承——特殊类的对象拥有其一般类的全部属性与服务，称做特殊类对一般类的继承；</li><li>多态性——是指在一般类中定义的属性或行为，被特殊类继承之后，可以具有不同的数据类型或表现出不同的行为。</li></ol></li><li>面向对象开发过程<br>算法与数据结构设计-源程序编辑-编译-连接-测试-调试</li></ol><h2 id="第二章-CPP-简单程序设计"><a href="#第二章-CPP-简单程序设计" class="headerlink" title="第二章 CPP 简单程序设计"></a>第二章 CPP 简单程序设计</h2><ol><li>什么是常量？什么是变量？<br>常量是指在程序运行的整个过程中其值始终不可改变的量，除了用文字表示常量外，也可以为常量命名，这就是符号常量；<br>在程序的执行过程中其值可以变化的量称为变量，变量是需要用名字来标识的。</li><li>符号常量<br>符号常量在声明时一定要赋值，而在程序中间不能改变其值。</li></ol><h2 id="第三章-函数"><a href="#第三章-函数" class="headerlink" title="第三章 函数"></a>第三章 函数</h2><ol><li>函数的调用关系<br>调用其他函数的函数称为主调函数，被其他函数调用的函数称为被调函数。</li><li>形参的作用<br>实现主调函数与被调函数之间的联系。函数在没被调用时形参只是一个符号，它标志着形参出现的位置应该有一个怎样的类型。只有在函数被调用时主调函数才将实参赋予形参。</li><li><code>return</code>的作用<ol><li>指定函数返回值</li><li>结束当前函数的执行</li></ol></li><li>函数的参数传递<br>指的就是形参与实参结合的过程，形实结合的方式有值传递和引用传递。<ol><li>值传递（为什么值传递不会造成值得改变？）<br>是指当发生函数调用时，给形参分配内存空间，并用实参来初始化形参（直接将实参的值传递给形参）。<br>但这一过程是单向的，一旦形参获得值之后便与实参脱离关系，形参值的改变不会造成实参的改变。</li><li>引用传递<br>用引用作为形参，在函数调用时发生的参数传递，称为引用传递。</li></ol></li><li>函数重载<br>两个以上的函数，具有相同的函数名，但是形参的个数或者类型不同，编译器根据实参和形参的类型和个数的最佳匹配，自动确定调用哪一个函数，这就是函数的重载。<br><em>⚠️ 注意：1⃣️ 重载的形参必须不同（个数或类型）；2⃣️ 如果要声明一个参数为空的函数，括号内必须写 void</em></li><li>函数声明与类型安全<br>不同类型的数据，在内存中都以二进制序列表示，在运行时并没有保存它的信息，有关类型的特性全部蕴含在了数据所执行的操作之中。正因如此，在使用变量前必须声明。</li><li>深度探索<ol><li><code>3-16</code></li></ol></li></ol><h2 id="第四章-类与对象"><a href="#第四章-类与对象" class="headerlink" title="第四章 类与对象"></a>第四章 类与对象</h2><ol><li>面向对象程序设计的主要特点<br>抽象、封装、继承和多态。</li><li>UML<ol><li>UML 规定数据成员表示的语法为：</li></ol></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[访问控制属性] 名称 [重数] [:类型] [=默认值] [&#123;约束特征&#125;]</span><br></pre></td></tr></table></figure><ol><li>UML 规定函数成员表示的语法为：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[访问控制属性] 名称 [(参数表)] [:返回类型] [&#123;约束特征&#125;]</span><br></pre></td></tr></table></figure><ol start="3"><li><p>抽象<br>对具体问题（对象）进行概括，抽出一类对象的公共性质并加以描述的过程。对一个问题的抽象分为两个方面：</p><ol><li>数据抽象：描述的是此类对象区别于彼类对象的属性或者状态；</li><li>行为抽象：描述的是某类对象的共同行为或功能特征。</li></ol></li><li><p>封装<br>就是将抽象得到的数据和行为（或功能）相结合，形成一个有机整体，也就是将操作数据和函数代码进行有机的结合，形成“类”。其中，数据和函数都是类的成员。</p><ol><li>public：为类提供外部接口；</li><li>protected：与私有类似，差别在于继承和派生时<code>派生类的成员函数可以访问基类的保护成员</code>。</li><li>private：隐蔽部分成员，达到对成员访问权限的合理控制，使不同的类之间的相互影响减少到最低限度，进而增强数据的安全性和简化程序编写工作。</li></ol></li><li><p>继承<br>允许程序员在原有类特性的基础上，进行更具体、更详细的说明。</p></li><li><p>多态<br>多态性是指一段程序能够处理多种类型对象的能力。在<code>CPP</code>中，这种多态性可以通过强制多态、重载多态、类型参数化多态、包含多态 4 种形式来实现。</p></li><li><p>结构体和联合体</p><table><thead><tr><th></th><th>控制访问权限</th><th>数据成员和函数成员</th><th>默认访问控制属性</th><th>全部数据成员共享一组内存</th><th>继承&#x2F;多态</th></tr></thead><tbody><tr><td>类</td><td>有</td><td>有</td><td>私有</td><td>否</td><td>是</td></tr><tr><td>结构体</td><td>有</td><td>有</td><td>公有</td><td>否</td><td>是</td></tr><tr><td>联合体</td><td>有</td><td>有</td><td>公有</td><td>是</td><td>否</td></tr></tbody></table></li><li><p>复制构造函数的调用场景</p><ol><li>当用类的一个对象去初始化一个新的同类的对象；</li><li>如果函数的形参是类对象，调用函数进行形参和实参结合时；</li><li>如果函数的返回值是类对象，函数调用完成返回时。</li></ol></li><li><p>复制构造函数和赋值运算符有何不同？<br>前置创建了一个新的对象，后者作用于已有对象。<br><em>⚠️ 注意：为什么要有类？用基本数据类型不行吗？每一种数据类型都包括了数据本身的属性以及对数据的操作。但基本数据类型的操作都是有限的。</em></p></li><li><p>拥有内嵌对象的构造函数调用顺序</p><ol><li>调用内嵌对象的构造函数，调用顺序按照内嵌对象在组合类的定义中出现的次序。</li><li>执行本类构造函数的函数体。<br><em>⚠️ 注意：内嵌对象在构造函数的初始化列表中出现的顺序与内嵌对象构造函数的调用顺序无关。</em></li></ol></li></ol><h2 id="第五章-数据的共享与保护"><a href="#第五章-数据的共享与保护" class="headerlink" title="第五章 数据的共享与保护"></a>第五章 数据的共享与保护</h2><ol><li>标识符的作用域和可见性<ol><li>作用域：指的是标识符的有效范围</li><li>可见性：标识符是否可以被引用 </li></ol></li><li>静态变量<br>不会随着每次函数调用产生副本，也不会随着函数返回而失效。也就是说，当一个函数返回时，下一次的调用，该变量还是会保持上一回的值（定义时未赋值会被初始化为<code>0</code>）。</li><li>对象生存期<ol><li>静态生存期<br>如果对象的生存期与程序的运行期相同，则称它具有静态生存期。</li><li>动态生存期<br>在局部作用域中声明的具有动态生存期的对象，习惯上也称为局部生存期对象。局部生存期对象诞生于声明点，结束于声明所在的块执行完毕之时。</li></ol></li><li>静态数据成员<br>静态数据成员具有静态生存周期。是描述类的所有对象共同特征的一个数据项，对于任何对象实例，它的属性值是相同的。<br>它是为了解决同一个类的不同对象之间数据和函数共享的问题的。</li><li>静态函数成员<br>静态成员函数可以直接访问该类的静态数据和函数成员。而访问非静态成员，必须通过对象名。</li><li>友元函数<br>在它的函数体中可以通过对象名访问类的私有和保护成员。<br>一般在<code>public</code>中声明。</li><li>友元类<br>若<code>A</code>类是<code>B</code>类的友元类，则<code>A</code>类的所有成员函数都是<code>B</code>类的友元函数，都可以访问<code>B</code>类的私有和保护成员。<br><em>⚠️ 注意：① 友元关系不可传递；② 友元关系是单向的；③ 友元关系是不被继承的。</em></li><li>共享数据的保护<br>对于既要共享又需要防止改变的数据应该声明为常量。对于无需改变对象状态的成员函数，都应当使用<code>const</code>。<ol><li>常对象在整个生存期内不能被改变；</li><li>常对象必须进行初始化，且不能被更新。<br><em>⚠️ 注意：类成员中的静态变量和常量都应当在类定义之外加以定义，但有个例外：类的静态常量如果有整数型或枚举类型可以直接在类定义中为它指定常量值。</em></li><li>常成员函数<ol><li><code>const</code>是函数类型的一个组成部分。</li><li>如果将一个对象说明为常对象，则通过该常对象<code>只能</code>调用它的常成员函数，而不能调用其他成员函数。这也是常对象唯一的对外接口方式。</li><li>无论是否通过常对象调用常成员函数，调用期间目的对象都被视为常对象，因此常成员函数不能更新目的对象的数据成员，也不能针对目的对象调用该类中没有<code>const</code>修饰的成员函数。</li><li><code>const</code>关键字可以用于对重载函数的区分。例如，如果在类中这样声明<code>void print(); void print() const;</code>这是对<code>print</code>的有效重载。</li><li>如果仅以<code>const</code>关键字为区分对成员函数重载，那么通过非<code>const</code>的对象调用该函数，两个重载的函数都可以与之匹配，这是编译器将选择最近的重载函数——不带<code>const</code>关键字的函数。</li></ol></li><li>常数据成员<ol><li>常数据成员只能通过初始化列表来获得初值。</li><li>静态常数据成员在类外说明和初始化。</li><li>类成员中的静态变量和常量都应当在类定义之外加以定义，整型和枚举型可以直接指定常量值。<code>eg. static const int b = 10;</code></li></ol></li><li>常引用<ol><li>常引用所引用的对象不能被更新。</li><li>一个常引用，无论绑定的是普通还是常对象，都只能把它当作常对象。</li></ol></li></ol></li><li>编译预处理<ol><li><code>#include</code>指令</li><li><code>#define</code>和<code>#undef</code>指令</li><li>条件编译指令<code>#if#elif#else#endif#ifdef#ifndef</code></li><li><code>defined</code>操作符<br>是一个预处理操作符，而不是指令，不用以<code>#</code>开头。使用方法：<code>defined(操作符)</code></li></ol></li></ol><h2 id="第六章-数组、指针和字符串"><a href="#第六章-数组、指针和字符串" class="headerlink" title="第六章 数组、指针和字符串"></a>第六章 数组、指针和字符串</h2><ol><li>指针变量是干什么的？<br>指针变量是用于存储内存单元地址的。</li><li>与地址相关的运算<code>*</code>和<code>&amp;</code><ol><li><code>*</code>：指针运算符，标识获取指针所指向变量的值。</li><li><code>&amp;</code>：取缔值运算符，用来得到一个对象的地址。</li></ol></li><li>指向常量的指针、指针类型的常量和 void 型指针<ol><li>指向常量的指针<code>const int * p = &amp;a</code>：p 本身值可以改变，但不能改变所指的对象。</li><li>指针类型的常量<code>int * const p = &amp;a</code>：p 本身的值不能改变。</li><li><code>viod</code>型指针可以访问任何类型的数据。</li></ol></li><li>用指针作为函数参数的作用<ol><li>使实参和形参指针指向共同的内存空间，以达到双向传递的作用；</li><li>减少函数调用时数据传递的开销；</li><li>通过指针向函数的指针传递函数代码的首地址。</li></ol></li><li>指针型函数</li><li>指向函数的指针<br>函数指针是专门用来存放函数代码首地址的变量。P212</li><li>对象指针</li><li>this 指针<br>它是一个隐含于每一个类的非静态成员函数中的特殊指针（包括构造函数和析构函数），它用于指向正在被成员函数操作的对象。</li><li>内存泄漏的原因<br><code>new</code>分配空间后，未用<code>delete</code>回收，导致程序占用内存越来越大。</li><li>用 vector 创建数组对象<br><code>vector&lt;int&gt;name(length, initValue);</code></li><li>深复制与浅复制<br>隐含的复制构造函数只能完成浅复制，因为两个指针指向的是同一内存地址。对于类的浅复制，当程序结束时，原对象和浅复制对象先后会调用两次析构函数，该空间会两次释放，程序出错。对象的深复制可以是循环赋值。P229</li></ol><h2 id="第七章-继承和派生"><a href="#第七章-继承和派生" class="headerlink" title="第七章 继承和派生"></a>第七章 继承和派生</h2><ol><li>类的继承与派生<ol><li>继承：新的类从已有类那里得到已有的特性。</li><li>派生：从已有类产生新类的过程就是类的派生。</li></ol></li><li>多继承、单继承和直接基类、间接基类<ol><li>单继承：一个派生类只有一个基类。</li><li>多继承：一个派生类有多个基类。</li><li>直接基类：直接参与派生出某类的基类。</li><li>间接基类：基类的基类甚至更高层的基类。</li></ol></li><li>继承方式<br>继承方式规定了如何访问从基类继承的成员。继承方式的关键字为：<code>public</code>，<code>protected</code>和<code>private</code>（默认）。<ol><li>公有继承（除构造函数和析构函数）：基类中的公有和保护成员在派生类中的访问属性不变，基类的私有成员不可直接访问。</li><li>保护继承：基类的公有成员和保护成员都以保护成员的身份出现在派生类汇总，而基类的私有成员不可直接访问。</li><li>私有继承：基类中的共有成员和保护成员都以私有成员身份出现在派生类中，而基类的私有成员在派生类中不可直接访问。如果在此被继承的话，基类的全部成员在新的派生类中就无法被直接访问。</li></ol></li><li>派生类成员<br>是指除了从基类继承来的所有成员（除了默认的构造函数和析构函数）之外，新增加的数据和函数成员。</li><li>派生类生成过程<ol><li>吸收基类成员</li><li>改造基类成员：着重学习不同继承方式下的基类成员的访问控制问题。① 基类成员的访问控制；② 对基类数据或函数成员的隐藏。</li><li>添加新的成员：构造与析构函数。</li></ol></li><li>类型兼容规则<br>类型兼容规则是指在需要基类对象的任何地方，都可以使用公有派生类的对象来替代。替代之后，派生类对象就可以作为基类的对象使用，但只能使用从基类继承的成员。</li><li>派生类的构造函数<br>派生类构造函数的执行情况：先调用基类的构造函数，然后调用内嵌对象的构造函数。基类构造函数的调用顺序是按照派生类定义时的顺序；内嵌构造函数调用顺序是按照成员在类中声明的顺序。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//派生类构造函数的一般语法形式</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">派生类名::派生类名(参数表): 基类名1(基类1初始化参数表),...,基类名n(基类n初始化参数表), 成员对象名1(成员对象1初始化参数表),...,成员对象名m(成员对象m初始化参数表) &#123;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span> public Base2, public Base1, public Base3 &#123;</span><br><span class="line">public:</span><br><span class="line">  Point(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d): Base1(a), member2(d), member1(c), Base2(b) &#123;&#125;</span><br><span class="line">private:</span><br><span class="line">  Base1 member1;</span><br><span class="line">  Base2 member2;</span><br><span class="line">  Base3 member3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>派生类的复制构造函数<br>如果程序员没有编写复制构造函数，编译系统会在必要时自动生成一个隐含的复制构造函数，这个隐含的复制构造函数会自动调用基类的复制构造函数，然后对派生类新增的成员对象一一执行复制。</li><li>派生类的析构函数<br>调用次序与构造函数相反。</li><li>虚基类<br>在派生类的对象中，同名的数据成员在内存中会有多个副本，同一函数名会有多个映射。可以使用作用域分辨符来唯一标识分别访问它们，也可以将共同基类设置为虚基类，这时从不同的路径继承过来的同名数据成员在内存中就只有一个副本，同一函数名也只有一个映射。</li><li>虚基类及其派生类构造函数<br>如果虚基类声明有非默认形式的（即带参数的）构造函数，并且<code>没有声明</code>默认形式的构造函数。这时，在整个继承关系中，直接或间接继承虚基类的所有派生类，都必须在构造函数的<code>成员初始化表中</code>列出对虚基类的初始化。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base0</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="comment">//未声明默认形式的构造函数</span></span><br><span class="line">    base0(<span class="type">int</span> var): var0(var) &#123;&#125;</span><br><span class="line">    <span class="type">int</span> var0;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">fun0</span><span class="params">()</span> &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;member of base0&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base1</span>:</span> virtual public base0 &#123;</span><br><span class="line">public:</span><br><span class="line">    base1(<span class="type">int</span> var): base0(var) &#123;&#125;</span><br><span class="line">    <span class="type">int</span> var1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base2</span>:</span> virtual public base0 &#123;</span><br><span class="line">public:</span><br><span class="line">    base2(<span class="type">int</span> var): base0(var) &#123;&#125;</span><br><span class="line">    <span class="type">int</span> var2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span>:</span> public base1, public base2 &#123;</span><br><span class="line">public:</span><br><span class="line">    derived(<span class="type">int</span> var): base0(var), base1(var), base2(var) &#123;&#125;</span><br><span class="line">    <span class="type">int</span> var;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;member of derived.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;starting...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    derived <span class="title function_">obj</span><span class="params">(<span class="number">1</span>)</span>;</span><br><span class="line">    obj.var0 = <span class="number">2</span>;</span><br><span class="line">    obj.fun0();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="12"><li>构造一个类的对象的一般顺序</li><li>如果该类有直接或间接的虚基类，则先执行虚基类的构造函数。</li><li>如果该类有其他基类，则按照他们在继承声明列表中出现的次序，分别执行他们的构造函数，但在构造过程中，不再执行他们的虚基类的构造函数。</li><li>按照在类定义中出现的顺序，对派生类中新增的成员对象进行初始化。对于类类型的成员对象，如未出现，则执行默认构造函数；对于基本数据类型的成员对象，如果出现在构造函数的初始化列表中，则使用其中指定的值为其赋值，否则什么也不做。</li><li>执行构造函数的函数体。</li><li>小结<br>派生类及其对象成员标识和访问问题：① 唯一标识问题；② 成员本身属性，即可见性问题。解决唯一标识问题介绍了同名隐藏规则、作用域分辨符和虚基类。</li></ol><h2 id="第八章-多态性"><a href="#第八章-多态性" class="headerlink" title="第八章 多态性"></a>第八章 多态性</h2><ol><li>什么是多态<br>多态是指同样的消息被<code>不同类型的对象</code>接收时导致不同的行为。 消息是指对类的成员函数的调用，不同的行为是指不同的实现，调用了不同的函数。</li><li>多态的类型<ol><li>重载多态*（专用多态）：普通函数和类的成员函数重载都叫做重载多态。</li><li>强制多态（专用多态）：是指将一个变元的类型加以变化，以符合一个函数或者操作的要求。加法运算符进行整型和浮点型运算时，首先进行类型强制转换，这就是强制多态的实例。</li><li>包含多态*（通用多态）：是类族中定义于不同类的同名成员函数的多态行为，主要通过虚函数实现。</li><li>参数多态（通用多态）：与类模板相关联，在使用时必须赋予实际的类型才可以实例化。</li></ol></li><li>多态的实现<ol><li>编译时多态</li><li>运行时多态（绑定：计算机程序自身彼此关联）<ol><li>静态绑定：绑定工作在编译链接阶段完成。</li><li>动态绑定：绑定工作在程序运行阶段完成。</li></ol></li></ol></li><li>运算符重载为成员函数<ol><li>双目运算符的左操作数是对象本身，由<code>this</code>指针指出，右操作数则需要通过运算符重载函数的参数表传递。</li><li>单目运算符操作数由对象的<code>this</code>指针给出，就不需要参数了。</li><li>后置运算符，重载为 A 类的成员函数，这时函数要带有一个整型（int）形参（用于和前置运算符相区别）。</li><li>前置运算符不用加形参。</li><li>仅需要访问参数对象的私有成员才将该函数声明为类的友元函数。</li></ol></li><li>运算符重载为非成员函数<ol><li>运算所需的操作数都要通过参数表传递。</li><li>参数表左右顺序就是运算符操作数顺序。</li><li>仅需要访问参数对象的私有成员才将该函数声明为类的友元函数。</li></ol></li><li>使用非成员函数重载的原因<ol><li>要重载的操作符的第一个操作数不是可以更改的类型，如<code>ostream</code>，是标准库类型，无法添加成员函数。</li><li>以非成员函数形式重载，支持更灵活的类型转换。</li></ol></li><li>虚函数<br>虚函数是动态绑定的基础。虚函数必须是非静态的成员函数。虚函数经过派生之后，在类族中就可以实现运行过程中的多态。<br>问题：如果用基类类型的指针指向派生类的对象，就可以通过这个指针来访问该对象，问题是当访问到的只是从基类继承来的同名成员。<br>解决办法：如果通过基类的指针指向派生类的对象，并通过这个指针访问某个与基类同名的成员，那么首先在<code>基类</code>中将该同名函数说明为虚函数。<br>这样就可以通过基类类型指针，使属于不同派生类的不同对象产生不同的行为，从而实现运行过程中的多态。</li><li>一般虚函数成员<br>虚函数声明只能出现在类定义中的函数原型声明中，不能出现在成员函数实现的时候。<br>运行过程中的多态需要满足 3 个条件：<ol><li>类之间满足赋值兼容规则。</li><li>要声明虚函数。</li><li>要由成员函数来调用或者是通过指针、引用来访问虚函数。*<br><em>⚠️ 注意：如果是使用对象名来访问虚函数，则绑定在编译过程中就可以进行（静态绑定），而无需再运行过程中进行。（<strong>只能用引用或指针来通过-&gt;访问</strong>，不然就是静态绑定输出的都是基类的成员函数。<strong>原因：</strong>基类的指针可以是派生类对象的别名，但是基类对象却不能表示派生类对象。）</em></li></ol></li><li>虚函数注意事项<ol><li>只有虚函数是动态绑定的。</li><li>如果派生类需要修改基类的行为（即重写与基类函数同名的函数），就应该在积累中将相应的函数声明为虚函数。而基类中的非虚函数，通常代表那些不希望被派生类改变的功能，也是不能实现多态的。</li></ol></li><li>虚析构函数<br>在<code>CPP</code>中不能声明虚构造函数，但是可以声明虚析构函数。析构函数无类型和参数，较为简单。虚析构函数设置之后，在使用指针就能够调用适当的析构函数针对不同的对象的清理工作。</li><li>纯虚函数<br>对于在基类中无法实现的函数，在基类中只说明函数原型用来规定整个类族的统一接口形式，而在派生类中再给出函数具体的实现。<br>声明格式：<code>virtual 函数类型 函数名(参数表)=0;</code></li><li>抽象类<br>带有纯虚函数的类是抽象类。抽象类的主要作用是通过它为一个类族建立一个公共的接口，使它们能够更有效发挥出多态特性。抽象类声明了一个类族派生类的公共接口，而接口的完整实现，要有派生类自己定义。<br>抽象类不能实例化。但是可以定义一个抽象类的指针和引用。通过指针或引用就可以指向并访问派生类的对象，进而访问派生类的成员，这种访问是具有多态特征的。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络 PART2</title>
      <link href="/yuque/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20PART2/"/>
      <url>/yuque/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20PART2/</url>
      
        <content type="html"><![CDATA[<h2 id="第四章-网络层"><a href="#第四章-网络层" class="headerlink" title="第四章 网络层"></a>第四章 网络层</h2><h3 id="（一）网络层的功能"><a href="#（一）网络层的功能" class="headerlink" title="（一）网络层的功能"></a>（一）网络层的功能</h3><ol><li>异构网络互联</li></ol><p>所谓网络互联，是指将两个以上的计算机网络，通过一定方法，用一种或多种通信处理设备（即中间设备）相互连接起来，以构成更大的网络系统。中间设备又叫中间系统或中继系统。</p><table><thead><tr><th>物理层中继系统</th><th>中继器、集线器</th></tr></thead><tbody><tr><td>数据链路层中继系统</td><td>网桥或交换机</td></tr><tr><td>网络层中继系统</td><td>路由器</td></tr><tr><td>网络层以上的中继系统</td><td>网关</td></tr></tbody></table><ol start="2"><li>路由与转发</li></ol><p>路由器的两大功能：</p><ol><li><p>路由选择</p></li><li><p>分组转发</p></li><li><p>拥塞控制</p><ol><li>判断网络是否进入拥塞状态的方法：观察网络的吞吐量与网络负载的关系<ol><li>若网络负载增加，网络吞吐量明显小于正常吞吐量，则可能已经进入“轻度拥塞”</li><li>若网络吞吐量随着网络负载的增大而下降，则可能已经进入拥塞状态</li><li>若网络的负载持续增大，而网络吞吐量下降为 0，则可能已经进入死锁状态</li></ol></li><li>拥塞控制的作用：确保子网能够承载所达到的流量，单一地增加资源不能解决拥塞</li><li>流量控制与拥塞控制的区别<br>| <strong>流量控制</strong> |</li></ol></li><li><p>流量控制往往是指在发送端和接收端之间的点对点通信量的控制</p></li><li><p>它所要做的是抑制发送端发送数据的速率，以便接收端来得及接收<br>|<br>| :—: | :— |<br>| <strong>拥塞控制</strong> |</p></li><li><p>确保通信子网能够传送待传送的数据</p></li><li><p>是一个全局性的问题</p></li><li><p>涉及网络中所有主机、路由器及导致网络传输能力下降的所有因素<br>|</p><ol><li>拥塞控制的方法<table><thead><tr><th>开环控制</th><th>描述</th><th>一种静态的预防方法。设计网络时先将有关发生拥塞的因素考虑周到，力求在工作时不产生拥塞，中途不再修改</th></tr></thead><tbody><tr><td></td><td>方法</td><td>包括确定何时可接收新流量、何时可丢弃分组及丢弃哪些分组，确定何种调度决策等。这些共性是，在做决定时不考虑当前网络状态</td></tr><tr><td>闭环控制</td><td>描述</td><td>基于反馈环路的概念，是一种动态的方法。</td></tr><tr><td></td><td>方法</td><td>事先不考虑有关网络拥塞的因素，采用系统监视，及时检测那里发生了拥塞，然后将拥塞信息传达到合适地方，以便调整网络的运行，并解决出现的问题</td></tr></tbody></table></li></ol></li></ol><h3 id="（二）路由算法"><a href="#（二）路由算法" class="headerlink" title="（二）路由算法"></a>（二）路由算法</h3><ol><li><p>静态路由与动态路由</p><ol><li>静态路由</li><li>动态路由<ol><li>常见的动态路由算法：① 距离-向量路由算法；② 链路状态路由算法</li></ol></li></ol></li><li><p>距离向量路由算法：① 向所有<strong>相邻结点</strong>发送；</p></li><li><p>链路状态路由算法：① 向网上<strong>所有其他结点</strong>发送；② 拥有完全拓扑信息</p></li><li><p>距离-向量路由算法与链路状态路由算法的比较</p><table><thead><tr><th>距离-向量路由算法</th><th>仅与邻居交谈，为邻居提供自己从自己到其他结点的最低费用估计</th><th></th></tr></thead><tbody><tr><td>链路状态路由算法</td><td>通过广播的方式与所有其他结点交谈，但仅告诉它们与它直接相连的费用</td><td></td></tr></tbody></table></li><li><p>层次路由</p></li></ol><p>因特网将整个互联网划分为许多较小的自治系统（注意一个自治系统包含很多局域网），每个自治系统有权自主决定本系统内应采用何种路由协议。如果两个自治系统需要通信，就需要有一种在两个自治系统之间的协议来“屏蔽”这种差异。据此，因特网把路由选择协议划分为两大类：</p><table><thead><tr><th></th><th>使用范围</th><th>具体协议</th></tr></thead><tbody><tr><td>内部网关协议 IGP</td><td>自治系统内部使用，也称域内路由选择</td><td>RIP（UDP）、OSPF（IP 数据报）</td></tr><tr><td>外部网关协议 EGP</td><td>自治系统间使用，也称域间路由选择</td><td>BGP（通过 TCP）</td></tr></tbody></table><p>在使用层次路由时，OSPF 将一个自治系统再划分为若干区域（Area），每个路由器都知道在本区域内如何把分组路由到目的地的细节，但不用知道其他区域的内部结构。</p><ol start="6"><li>两个概念<ol><li>慢收敛：在距离-向量路由选择协议中，“好消息传得快，坏消息传得慢”，这就导致了当路由信息发生变化时，该变化未能及时地被所有路由器知道，而仍然可能在路由器之间进行传递，这就是“慢收敛”现象。慢收敛是导致发生路由回路的根本原因</li><li>直接交付与间接交付：路由选择分为直接和间接交付，当发送站与目的站在同一网段时，就使用直接交付，反之使用间接交付。（间接交付地最后一个路由器还是直接交付）</li></ol></li></ol><h3 id="（三）IPv4"><a href="#（三）IPv4" class="headerlink" title="（三）IPv4"></a>（三）IPv4</h3><ol><li>IPv4 分组格式：<strong>P148</strong></li><li>IPv4 地址</li></ol><p>A(1-126)，B(128-191)，C(192-223)，D(224-239)，E(240-255)，注意：</p><ol><li>A 类地址可用网络数为<img src="https://cdn.nlark.com/yuque/__latex/15f1fdb80843660b9c1ddec64686f90b.svg#card=math&code=2%5E7-2%0A&height=20&width=45">，因为：① 全 0 保留不用；②127 为回环</li><li>B 类地址可用网络数为<img src="https://cdn.nlark.com/yuque/__latex/844495834dc496c5ab2bb75dd4c172be.svg#card=math&code=2%5E%7B14%7D-1&height=20&width=50">，因为：128.0 这个网络不可指派</li><li>C 类地址可用网络数为，因为<img src="https://cdn.nlark.com/yuque/__latex/25d3ef61a1ddb721fba32443872207d7.svg#card=math&code=2%5E%7B21%7D-1&height=20&width=50">，：192.0.0 这个网络不可指派</li><li>IP 地址的重要特点<ol><li>管理机构只分配网络号</li><li>IP 网络上的路由器至少有两个 IP 地址</li><li>用转发器或桥接器（网桥等）连接的若干 LAN 仍然是同一个网络（同一个广播域），因此该 LAN 中的所有主机的 IP 地址的网络号必须相同</li><li>路由器总是有两个或两个以上的 IP 地址，路由器的每个端口都有一个不同网络号的 IP 地址</li></ol></li><li>私有地址<ol><li>A 类：10.0.0.0 - 10.255.255.255</li><li>B 类：172.16.0.0 - 172.31.255.255</li><li>C 类：192.168.0.0 - 192.168.255.255</li></ol></li><li>普通路由器与 NAT 路由器的区别</li></ol><p>普通路由器仅工作在网络层，而 NAT 路由器转发数据报时需要查看和转换传输层端口号，所以工作在传输层</p><ol start="6"><li>子网划分与 CIDR</li><li>IP 与硬件地址</li></ol><p>由于路由器的隔离且 IP 数据报被路由转发时，此 IP 分组在每个网络中都被路由器解封再封装，所使用的 MAC 地址一直在变。所以 IP 网络中无法通过广播的方式依靠 MAC 地址来完成跨网络的寻址，因此在 IP 网络的网络层只是用 IP 地址来完成寻址。IP 分组到达目标网络后，改为在目标 LAN 中通过数据链路层的 MAC 地址以广播方式寻址。<br>路由器由于互联多个网络，因此它不仅有多个 IP 地址，也有多个硬件地址。</p><ol start="8"><li>ARP</li></ol><p>工作在网络层。每台主机都有 ARP 高速缓存表，使用 ARP 来动态更新。ARP 请求分组是广播，但 ARP 相应分组是单播。</p><ol start="9"><li>DHCP</li></ol><p>DHCP 是应用层协议，基于 UDP，使用客户&#x2F;服务器模式，全程使用多播</p><ol start="10"><li>ICMP</li></ol><p>工作在网络层。PING 工作在应用层，直接使用 ICMP，而未使用 TCP 或 UDP。Traceroute&#x2F;Tracert 工作在网络层</p><h3 id="（四）IPv6"><a href="#（四）IPv6" class="headerlink" title="（四）IPv6"></a>（四）IPv6</h3><ol><li>长度：128 位</li><li>目的地址类型：<ol><li>单播</li><li>多播</li><li>任播：目的站是一组计算机，但数据报在交付时只交付其中一台主机（实为一对一）</li></ol></li><li>IPv4 向 IPv6 的过渡方法<ol><li>双协议栈技术</li><li>隧道技术</li></ol></li></ol><h3 id="（五）路由协议"><a href="#（五）路由协议" class="headerlink" title="（五）路由协议"></a>（五）路由协议</h3><ol><li>RIP<ol><li>基于：距离向量</li><li>规定：<ol><li>维护自身到其他每个目的网络的距离记录</li><li>每经过一个<strong>路由器</strong>，距离（跳数）+1</li><li>RIP 最多只能包含 15 个路由器。因此，距离为 16 时，表示网络不可达（只适用于小型互联网）</li><li>每 30s 广播一次 RIP 路由更新信息，以便自动建立并维护路由表（动态维护）</li><li>RIP 中不支持子网掩码的 RIP 广播，所以子网掩码必须相同。RIP2 中可以使用变长子网掩码和 CIDR</li></ol></li><li>特点：<ol><li>仅和相邻路由器交换信息</li><li>交换的信息是当前路由器知道的<strong>所有</strong>路由表</li><li>每隔 30s 交换一次信息</li></ol></li></ol></li><li>OSPF<ol><li>OSPF 与 RIP 的区别：<ol><li>向自治系统全部主机发信息，泛洪法</li><li>交换的信息是与本路由器相邻的所有路由器的链路状态</li><li>只有链路变化是才会使用泛洪法发送此信息</li><li><strong>OSPF 是网络层协议</strong>，直接使用 IP 数据报传送；而<strong>RIP 是应用层协议</strong>，它在传输层使用 UDP</li></ol></li><li>特点：<ol><li>可根据不同类型的业务可计算出不同的路由</li><li>多路径之间的负载平衡</li><li>在 OSPF 路由器之间交换的分组具有鉴别功能，保证了仅在可信赖的路由器之间交换链路状态信息</li><li>支持可变子网划分和 CIDR</li><li>每个链路状态都带上了一个 32 位的序号，序号越大，状态越新</li></ol></li><li>OSPF 分组类型：TODO</li></ol></li><li>边界网关协议（BGP）</li></ol><p>只能力求寻找到一条能够到达目的网络且比较好的路由（不能兜圈子），而并非一条最佳路由。</p><ol><li>基于：路径向量路由选择协议</li><li>每个自治系统的管理员选择至少一个路由器，作为该自治系统的“BGP 发言人”</li><li>每个“BGP 发言人”除了运行 BGP 之外，还需运用该 AS 所用的内部网关协议</li><li>特点：<ol><li>BGP 路由交换信息的节点数量级是自治系统的数量级</li><li>每个自治系统发言人数目较少</li><li>支持 CIDR</li><li>在 BGP 刚运行时，BGP 的临站交换整个 BGP 路由表，以后只需更新变化的部分</li></ol></li><li>分组类型：TODO</li><li>三种协议的比较<table><thead><tr><th><strong>协议</strong></th><th><strong>RIP</strong></th><th><strong>OSPF</strong></th><th><strong>BGP</strong></th></tr></thead><tbody><tr><td>类型</td><td>内部</td><td>内部</td><td>外部</td></tr><tr><td>路由算法</td><td><strong>距离</strong>-向量</td><td>链路状态</td><td><strong>路径</strong>-向量</td></tr><tr><td>传递协议</td><td>UDP</td><td>IP</td><td>TCP</td></tr><tr><td>路径选择</td><td>跳数最少</td><td>代价最低</td><td>较好，非最佳</td></tr><tr><td>交换节点</td><td>和本结点相邻的路由器</td><td>网络中所有路由器</td><td>和本结点相邻的路由器</td></tr><tr><td>交换内容</td><td>当前本路由器知道的全部信息，即自己的路由表</td><td>与本路由器相邻的所有路由器的链路状态</td><td>首次：整个路由表</td></tr><tr><td></td><td></td><td></td><td>非首次：有变化的部分</td></tr></tbody></table></li></ol><h3 id="（六）IP-组播"><a href="#（六）IP-组播" class="headerlink" title="（六）IP 组播"></a>（六）IP 组播</h3><p>为了能够支持像视频点播和视频会议这样的多媒体应用，是让源主机一次发送的单个分组可以抵达用一个组播地址标识的若干目标主机，并被它们正确接收。组播一定仅用于 UDP。<br>主机可以选择加入或离开一个组，因此同一台主机可能属于多个组。</p><ol><li>IP 组播地址</li></ol><p>使用 D 类地址，范围是 224.0.0.0 ~ 239.255.255.255，每个 D 类 IP 地址标志一个组播组。<br>注意：</p><ol><li>组播数据报也是“尽最大努力交付”，不提供可靠服务</li><li>组播地址只可用于目的地址</li><li>对组播数据报不产生 ICMP 差错报文</li><li>并非所有 D 类地址都可用于组播</li><li>IP 组播的分类<ol><li>只在本局域网上进行硬件组播</li><li>在因特网的范围内进行组播：在最后阶段，还是要把组播数据报在局域网上用硬件组播交付给组播组的所有成员</li></ol></li><li>硬件组播</li></ol><p>IANA 拥有的以太网组播地址的范围是从：01-00-5E-00-00-00 到 01-00-5E-7F-FF-FF，只有 23 位用于组播。<br>D 类 IP 地址可供分配的有 28 位，前 5 位不能用来构成以太网地址，因此只有<strong>后 23 位</strong>可用作组播；<br>IP 地址的后 23 位映射到 MAC 地址；<br>因为映射不是唯一的，还需要在 IP 层利用软件进行过滤，把不是本主机要接受的数据报丢弃。</p><ol start="4"><li>IGMP 与组播路由算法<ol><li>IGMP 让连接到本地局域网上的组播路由器知道本局域网上是否有主机参加或退出了某个组播组</li><li>ICMP 的工作阶段<ol><li>某台主加入新的组播组时，该主机应向组播路由器发送一个 IGMP 报文，声明自己要成为该组成员；本地组播路由器收到 IGMP 报文后，将组成员关系发给因特网上的其他组播路由器</li><li>组成员关系是动态的，本地组播路由器要周期性地探寻本地局域网上的主机；但一个组在经过几次的探寻后仍然没有一台主机响应时，则不再将该组的成员关系转发给其他组播路由器</li></ol></li><li>组播路由选择实际上就是要找出以源主机根节点的组播转发树（避免环路路由）；不同多播组对应于不同的多播转发树；同一多播组，对不同的源点也会有不同的多播转发树</li></ol></li><li>在许多由路由器互联的支持硬件多点传送的网络上实现因特网组播时，主要有三种路由算法：<ol><li>基于链路状态</li><li>基于距离向量的路由选择</li><li>可以建立在任何路由器协议之上，称为<strong>协议无关的组播（PIM）</strong></li></ol></li></ol><h3 id="（七）移动-IP"><a href="#（七）移动-IP" class="headerlink" title="（七）移动 IP"></a>（七）移动 IP</h3><p>移动 IP 技术是指<strong>移动节点以固定的网络 IP 地址</strong>，实现跨越不同网段的漫游功能，并保证基于网络 IP 的网络权限在漫游过程中不发生任何改变。使用移动 IP 可以在不改变其 IP 地址的情况下改变其驻留位置。<br>即为移动结点设置了两个 IP 地址：一个主地址、一个辅地址（转交地址）</p><ol><li>移动 IP 定义的功能实体：<ol><li>移动结点：具有永久 IP 地址的移动结点</li><li>本地代理：在归属网络中代表移动节点执行移动管理功能的实体成为归属代理（本地代理）。它根据移动用户的转交地址，采用隧道技术转交移动结点的数据包</li><li>外部代理：在外部网络中帮助移动结点完成移动管理功能的实体成为外部代理</li></ol></li><li>移动 IP 通信过程：<strong>P197</strong></li></ol><h3 id="（八）网络层设备"><a href="#（八）网络层设备" class="headerlink" title="（八）网络层设备"></a>（八）网络层设备</h3><ol><li>路由器的选择和功能：<strong>P199</strong><ol><li>任务：连接异构网络并完成路由转发</li><li>结构：<ol><li>路由选择</li><li>分组转发</li></ol></li><li>路由器与网桥的区别：网桥和高层协议无关，路由器是面向协议的。它根据网络地址进行操作，并进行路径选择、分段、帧格式转换、对数据报的生存时间和流量进行控制等。</li><li>路由器支持的协议：OSI、TCP&#x2F;IP、IPX 等</li></ol></li><li>路由表与路由转发<ol><li>路由表的项目：<ol><li>目的网络 IP 地址</li><li>子网掩码</li><li>下一跳 IP 地址</li><li>接口</li></ol></li><li>转发表</li></ol></li></ol><p>转发表由路由表得出；转发表中含有一个分组将要发往的目的地址，以及分组的下一跳（即下一步接收者的目的地址，实际为 MAC 地址），为减少转发表的重复项目，可使用默认路由代替所有具有相同下一跳的项目，并将默认路由设置得比其他项目的优先级低。</p><ol start="3"><li>转发和路由的区别<ol><li>“转发”是路由器根据转发表把收到的 IP 数据报从合适的端口转发出去，它仅涉及路由器</li><li>“路由选择”则涉及很多路由器，路由表是许多路由器协同工作的结果</li><li>分组的转发实际上是靠直接查找转发表，而不是直接查找路由表</li></ol></li></ol><h2 id="第五章-传输层"><a href="#第五章-传输层" class="headerlink" title="第五章 传输层"></a>第五章 传输层</h2><h3 id="（一）传输层提供的服务"><a href="#（一）传输层提供的服务" class="headerlink" title="（一）传输层提供的服务"></a>（一）传输层提供的服务</h3><ol><li>传输层的功能<ol><li>提供应用进程之间的逻辑通信（即端到端的通信）</li><li>复用和分用：<ol><li>复用：发送方不同的应用进程可以使用同一个传输层协议传送数据（网络层复用是指发送方不同协议的数据可以封装成 IP 数据报发送出去）</li><li>分用：接收方的传输层在剥去首部之后能够把数据正确交付到目的的应用进程（网络层分用是指接收方在剥去首部之后把数据交付给相应的协议）</li></ol></li><li>传输层对收到的报文进行差错检测（首部和数据部分）。而网络层只检查首部</li><li>提供两种不同的传输协议，即面向连接的 TCP 和无连接的 UDP。而网络层无法同时实现两种协议（即在网络层要么只提供面向连接的服务，如：虚电路；要么只提供无连接服务，如数据报，而不能共存）</li></ol></li><li>传输层寻址与端口<ol><li>TSAP： 端口，通过端口来标识主机中的应用进程</li><li>端口号：只标识本计算机应用层中的各进程</li><li>套接字：唯一标识网络上一台主机和其上的一个应用（进程）<ol><li>套接字 &#x3D; （主机地址，端口号）</li></ol></li></ol></li><li>无连接和面向连接服务<ol><li>采用 TCP 时，传输层向上提供的是一条<strong>全双工</strong>的<strong>可靠逻辑信道</strong></li><li>采用 UDP 时，传输层向上提供的是一条不可靠的逻辑信道，它在 IP 之上提供两个附加服务：多路复用和对数据的错误检查</li></ol></li><li>IP 数据报和 UDP 数据报的区别：P212</li><li>TCP 和网路层虚电路的区别：P212</li></ol><h3 id="（二）UDP"><a href="#（二）UDP" class="headerlink" title="（二）UDP"></a>（二）UDP</h3><ol><li>UDP 数据报<ol><li>概述：UDP 只是做了传输协议能够做的最少工作，仅在 IP 的数据包服务上增加了两个最基本的服务：<strong>复用和分用</strong>以及<strong>差错检测</strong></li></ol></li><li>UDP 的优点<ol><li>无需建立连接</li><li>无连接状态</li><li>分组首部开销小。TCP 有<strong>20B</strong>的首部，UDP 仅有<strong>8B</strong></li><li>应用层可以更好地控制要发送的数据和发送时间。UDP 无拥塞控制</li><li>UDP 是面向报文的。发送方 UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界；<strong>因此报文不可分割，是 UDP 数据报处理的最小单位。</strong></li></ol></li><li>UDP 的首部格式<ol><li>源端口号：在需要对方回信时选用</li><li>目的端口：在终点交付时必须使用到</li><li>长度：UDP 数据报的长度，最小值是 8（UDP 首部长度）</li><li>校验和：检测 UDP 中数据是否有错。有错就丢弃。</li></ol></li></ol><p><em>当分用时的端口不正确，UDP 会丢弃报文，并用 ICMP 发送“端口不可达”报文给发送方。</em></p><ol start="4"><li>UDP 校验</li></ol><p>在计算校验和时，要在 UDP 数据包之前增加 12B 的伪首部，伪首部并不是 UDP 真正的首部。只是在计算校验和时临时添加到前面的，得到一个临时的 UDP 数据报。伪首部包括：源 IP 地址、目的 IP 地址、0、17、UDP 长度。<br><strong><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1302535/1604214951075-42fd66d7-ee33-4c8c-b776-74f92e037611.jpeg#align=left&display=inline&height=319&margin=%5Bobject%20Object%5D&name=IMG_20201101_151331.jpg&originHeight=2474&originWidth=4000&size=2436635&status=done&style=none&width=515" alt="IMG_20201101_151331.jpg"></strong><br><strong>校验过程：</strong><br><strong><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1302535/1604217649059-69d22c04-ab4e-4a83-84b5-20a4ff45105d.jpeg#align=left&display=inline&height=309&margin=%5Bobject%20Object%5D&name=notepad1604217507962.jpg&originHeight=960&originWidth=1851&size=785738&status=done&style=none&width=595" alt="notepad1604217507962.jpg"></strong><br><em>注意：若校验结果为全 0，则校验位全写 1。</em></p><h3 id="（三）TCP"><a href="#（三）TCP" class="headerlink" title="（三）TCP"></a>（三）TCP</h3><ol><li>TCP 段</li></ol><p>主要解决传输的可靠、有序、无丢失和不重复问题。</p><ol><li>TCP 协议的特点<ol><li>TCP 是<strong>面向连接</strong>的传输层协议</li><li>每条 TCP 连接只能有两个端点，每条 TCP 连接只能是<strong>点对点</strong>的</li><li>TCP 提供可靠的交付服务，<strong>可靠有序、不丢不重</strong>。</li><li>TCP 提供<strong>全双工</strong>通信，允许通信双方的应用进程在任何时候发送数据</li><li>TCP 连接的两端都设有<strong>发送缓存</strong>和<strong>接收缓存</strong></li><li>发送缓存存放：① 准备发送的数据；② 已发送但未确认的数据</li><li>接收缓存存放：① 按需到达，但是未被接收应用程序读取的数据；② 不按序到达的数据</li><li>TCP 是<strong>面向字节流</strong>的，虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅视为一连串的无结构字节流</li></ol></li><li>TCP 的报文段：<strong>P221 - P223</strong></li><li>TCP 连接管理</li><li>TCP 可靠传输</li><li>TCP 流量控制与拥塞控制</li></ol><h2 id="第六章-应用层"><a href="#第六章-应用层" class="headerlink" title="第六章 应用层"></a>第六章 应用层</h2><h3 id="（一）网络应用模型"><a href="#（一）网络应用模型" class="headerlink" title="（一）网络应用模型"></a>（一）网络应用模型</h3><ol><li>客户&#x2F;服务器模型</li><li>P2P 模型</li><li>区别<table><thead><tr><th></th><th align="center"><strong>C&#x2F;S</strong></th><th align="center"><strong>P2P</strong></th></tr></thead><tbody><tr><td>特点</td><td align="center"></td><td align="center"></td></tr></tbody></table></li><li>客户是服务请求方，服务器是服务提供方</li><li>客户机是面向用户的，服务机是面向任务的</li><li>网络中计算机的地位不平等，服务器可以对用户权限的限制来达到管理客户机的目的</li><li>客户机互相之间不直接通信</li><li>可扩展性不佳<br>|</li><li>任意一堆计算机称为——对等方</li><li>每个结点即作为客户，也作为服务器</li><li>P2P 是逻辑网络，而非物理网络<br>|<br>| | |<br>| 对比 | C&#x2F;S 对比 P2P 来说的优点：</li><li>减轻了服务器压力，消除了对服务器的完全依赖，可以将任务分配到各个结点，大大提高了系统效率和资源利用率</li><li>多个客户机之间可以直接共享文档</li><li>可扩展性好</li><li>网络健壮性强<br>| |<br>| 缺点 | |</li><li>在获取服务的同时，还要提供服务，因此占用了较高的内存，从而影响整机速度</li><li>占用较高的带宽<br>|</li></ol><h3 id="（二）域名系统"><a href="#（二）域名系统" class="headerlink" title="（二）域名系统"></a>（二）域名系统</h3><h3 id="（三）文本传输协议"><a href="#（三）文本传输协议" class="headerlink" title="（三）文本传输协议"></a>（三）文本传输协议</h3><h3 id="（四）电子邮件"><a href="#（四）电子邮件" class="headerlink" title="（四）电子邮件"></a>（四）电子邮件</h3><h3 id="（五）万维网"><a href="#（五）万维网" class="headerlink" title="（五）万维网"></a>（五）万维网</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络 PART1</title>
      <link href="/yuque/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20PART1/"/>
      <url>/yuque/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20PART1/</url>
      
        <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1302535/1602575229502-c57fb459-983f-4686-bb0b-18dca7ace558.jpeg#align=left&display=inline&height=1080&margin=%5Bobject%20Object%5D&name=overwatch5.jpg&originHeight=1080&originWidth=1920&size=662348&status=done&style=none&width=1920" alt="overwatch5.jpg"></h2><h2 id="第一章-计算机网络体系结构"><a href="#第一章-计算机网络体系结构" class="headerlink" title="第一章 计算机网络体系结构"></a>第一章 计算机网络体系结构</h2><h3 id="（一）相关概念"><a href="#（一）相关概念" class="headerlink" title="（一）相关概念"></a>（一）相关概念</h3><ol><li><p><strong>计算机网络的概念</strong></p><table><thead><tr><th><strong>广义观点</strong></th><th></th><th></th></tr></thead><tbody><tr><td><strong>资源共享观点</strong></td><td>以能够相互共享资源的方式互联起来的自治计算机系统的集合。① 目的：资源共享；② 组成单位：分布在不同地理位置的多台独立的“自治计算机”；③ 网络中的计算机必须遵从统一规则——网络协议。</td><td></td></tr><tr><td><strong>用户透明性观点</strong></td><td></td><td></td></tr></tbody></table></li><li><p><strong>计算机网络的组成</strong></p><table><thead><tr><th><strong>从组成部分上看</strong></th><th></th><th></th></tr></thead><tbody><tr><td><strong>从工作方式上看</strong></td><td></td><td></td></tr><tr><td><strong>从功能组成上看</strong></td><td><strong>通信子网：</strong>由各种传输介质、通信设备和相应的网络协议组成，它使网络具有数据传输、交换、控制和存储的能力，实现计算机之间的数据通信。</td><td><strong>资源子网：</strong>实现资源共享功能的设备及其软件的集合，向网络用户提供共享其他计算机上的硬件资源、软件资源和数据资源的服务。</td></tr></tbody></table></li><li><p>计算机网络的功能</p><ul><li>数据通信</li><li>资源共享</li><li>分布式处理</li><li>提高可靠性</li><li>负载均衡</li></ul></li><li><p>计算机网络的分类<br>| 按分布范围 |</p></li><li><p>广域网 WAN</p></li><li><p>城域网 MAN</p></li><li><p>局域网 LAN</p></li><li><p>个人局域网 PAN<br>| | |<br>| — | — | — | — |<br>| 按传输技术 |</p></li><li><p>广播式网络</p></li><li><p>点对点网络<br>| | 是否采用分组存储转发与路由选择机制是点对点是网络与广播式网络的重要区别，广域网基本都属于点对点网络。 |<br>| 按拓扑分类 | 星形、总线形、环形和网络形 | | |<br>| 按使用者分类 | 公用网和专用网 | | |<br>| 按交换技术分类 |</p></li><li><p>电路交换网络</p></li><li><p>报文交换网络</p></li><li><p>分组交换网络<br>| | |<br>| 按传输介质分类 | 无线 | 有线 | |</p></li><li><p>交换技术分类</p><table><thead><tr><th></th><th>概述</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>电路交换网络</td><td></td><td></td><td></td></tr><tr><td>报文交换网络</td><td></td><td></td><td></td></tr><tr><td>分组交换网络</td><td></td><td></td><td></td></tr></tbody></table></li><li><p>网络性能指标</p><ul><li>宽带</li><li>时延<ul><li>发送时延</li><li>传播时延</li><li>处理时延</li><li>排队时延</li></ul></li><li>时延带宽积</li><li>往返时延 RTT</li><li>吞吐量</li><li>速率</li><li>信道利用率</li></ul></li></ol><h3 id="（二）计算机网络协议、接口、服务和网络模型"><a href="#（二）计算机网络协议、接口、服务和网络模型" class="headerlink" title="（二）计算机网络协议、接口、服务和网络模型"></a>（二）计算机网络协议、接口、服务和网络模型</h3><ol><li>计算机网络协议、接口和服务</li><li>服务类型（面向连接和无连接的服务协议）及相关协议</li><li>OSI&#x2F;RM 分层及各层协议</li><li>TCP&#x2F;IP 模型</li><li>OSI&#x2F;RM 与 TCP&#x2F;IP 的比较</li></ol><h3 id="（三）疑难点总结"><a href="#（三）疑难点总结" class="headerlink" title="（三）疑难点总结"></a>（三）疑难点总结</h3><h2 id="第二章-物理层"><a href="#第二章-物理层" class="headerlink" title="第二章 物理层"></a>第二章 物理层</h2><h3 id="（一）通信基础"><a href="#（一）通信基础" class="headerlink" title="（一）通信基础"></a>（一）通信基础</h3><ol><li>速率、波特与带宽</li><li>奈奎斯特定理和香农定理</li><li>编码与调制</li><li>基带传输与宽带传输（频带传输）</li></ol><h3 id="（二）物理层的设备"><a href="#（二）物理层的设备" class="headerlink" title="（二）物理层的设备"></a>（二）物理层的设备</h3><ol><li>中继器</li><li>集线器</li><li>冲突域和广播域</li><li></li></ol><h2 id="第三章-数据链路层"><a href="#第三章-数据链路层" class="headerlink" title="第三章 数据链路层"></a>第三章 数据链路层</h2><h3 id="（一）数据链路层的功能"><a href="#（一）数据链路层的功能" class="headerlink" title="（一）数据链路层的功能"></a>（一）数据链路层的功能</h3><ol><li>概述及主要功能</li><li>数据链路层提供的服务<ol><li>无确认无连接服务</li><li>有确认无连接服务</li><li>有确认面向连接服务</li></ol></li></ol><p><em>注：有确认就一定要有连接，即不存在无确认的面向连接的服务</em></p><ol start="3"><li><p>流量控制</p><table><thead><tr><th></th><th>控制对象</th><th>方法</th></tr></thead><tbody><tr><td>数据链路层</td><td>相邻节点间数据链路层的流量</td><td>限制发送方的速率</td></tr><tr><td>传输层</td><td>控制源端到目的端之间的流量</td><td></td></tr></tbody></table></li><li><p>差错控制</p><ol><li>位错<ol><li>解决办法：<strong>循环冗余校验</strong>（CRC）方式发现位错，通过<strong>ARQ</strong>方式重传出错帧</li></ol></li><li>帧错<ol><li>分类：① 丢失；② 重复；③ 失序</li><li>解决办法：定时器（<strong>①</strong>）；编号机制（<strong>②③</strong>）</li></ol></li></ol></li></ol><h3 id="（二）组帧"><a href="#（二）组帧" class="headerlink" title="（二）组帧"></a>（二）组帧</h3><ol><li>组帧的目的：把比特组合成帧为单位传输，是为了在出错时只重发出错的帧，而不是全部数据，从而提高效率</li><li>组帧要解决的问题<ol><li>帧定界</li><li>帧同步</li><li>透明传输</li></ol></li><li>组帧方法（常用后两种）<ol><li>字符计数法</li><li>字符填充的首位定界法</li><li>零比特填充法：逢 5 个 1 添 0</li><li>违规编码法</li></ol></li></ol><h3 id="（三）差错控制"><a href="#（三）差错控制" class="headerlink" title="（三）差错控制"></a>（三）差错控制</h3><ol><li>差错原因：噪声引起的</li><li>噪声的分类<ol><li>全局性<ol><li>由于线路本身电气特性产生的随机噪声（热噪声），固有的</li><li>解决办法：提高信噪比或避免干扰（对传感器下手）</li></ol></li><li>局部性<ol><li>外界特定的短暂因素造成的冲击噪声，是产生差错的主要原因</li><li>利用<strong>编码技术</strong>解决</li></ol></li></ol></li><li>编码技术 - 检错编码<ol><li>奇偶校验码</li><li>循环冗余码<ol><li>检错过程：每个帧初以同样的除数，得余数 R，为 0 则接受，反之。（即，只要接收了，就认为该帧无差错。）</li></ol></li></ol></li><li>编码技术 - 纠错编码<ol><li>海明码：发现双比特错，纠正单比特错</li><li>海明距<strong>？</strong><ol><li><strong>纠错 d 位，码距 2d+1</strong></li><li><strong>检错 d 位，码距 d+1</strong></li></ol></li></ol></li></ol><h3 id="（四）流量控制与可靠传输机制"><a href="#（四）流量控制与可靠传输机制" class="headerlink" title="（四）流量控制与可靠传输机制"></a>（四）流量控制与可靠传输机制</h3><blockquote><p>数据链路层中的流量控制机制和可靠传输机制是交织在一起的</p></blockquote><p><strong>流量控制：</strong></p><ol><li>停止-等待流量控制基本原理：发送方 -&gt; 确认 -&gt; 再发送</li><li>滑动窗口的特性<ol><li>只有接收窗口向前滑动（同时接收方发送了确认帧）时，发送窗口才有可能（只有发送方收到确认帧后才一定）向前滑动；</li><li>滑动窗口的大小</li><li>接收窗口为 1 时，可保证帧的有序接收</li><li>数据链路层的滑动窗口协议中，窗口的大小在传输过程中是固定的（<strong>注意与传输层的滑动窗口协议的区别</strong>）</li></ol></li></ol><p><strong>可靠传输：</strong></p><ol start="3"><li>可靠传输机制（数据链路层）<ol><li>确认</li><li>超时重传：发送方定时器超时，重传</li></ol></li><li>ARQ 进行流量控制（点到点）的方法</li></ol><table><thead><tr><th></th><th><strong>发送窗口大小</strong></th><th><strong>接收窗口大小</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>停止-等待 ARQ</td><td>&#x3D;1</td><td>&#x3D;1</td><td></td></tr><tr><td>后退 N 帧 ARQ</td><td>&gt;1</td><td>&#x3D;1</td><td>滑动窗口技术和请求重发技术的结合</td></tr><tr><td>选择性重传 ARQ</td><td>&gt;1</td><td>&gt;1</td><td></td></tr></tbody></table><ol start="5"><li><p>ARQ</p><table><thead><tr><th></th><th><strong>确认方式</strong></th><th><strong>接收顺序</strong></th><th><strong>重传范围</strong></th><th><strong>是否有定时器</strong></th><th><strong>是否有缓存</strong></th><th><strong>窗口大小</strong></th></tr></thead><tbody><tr><td>停止-等待</td><td>逐一确认</td><td>按序接收</td><td>对应帧</td><td>是</td><td>双方都有</td><td>1</td></tr><tr><td>GBN</td><td>累积确认</td><td>按序接收</td><td>出错帧及之后所有帧</td><td>是</td><td></td><td>-1</td></tr><tr><td>SR</td><td>逐一确认</td><td>&#x2F;</td><td>只重传错帧</td><td>是</td><td>接收方有，大小与窗口大小相等</td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></li><li><p><strong>书上笔记</strong></p></li><li><p>发送周期：T，周期内发送 L 比特数据，传输速率为 C，则发送有效数据的时间为 L&#x2F;C，在这种情况下：</p><ol><li>信道利用率 &#x3D; (L&#x2F;C)&#x2F;T</li><li>信道吞吐率 &#x3D; 信道利用率 * 发送方的发送速率</li><li><strong>不同方式下的利用率、吞吐率计算</strong></li></ol></li></ol><h3 id="（五）介质访问控制"><a href="#（五）介质访问控制" class="headerlink" title="（五）介质访问控制"></a>（五）介质访问控制</h3><ol><li>任务：隔离来自同一信道上其他结点所传送的信号，以协调活动结点的传输。用来决定广播信道中信道分配的协议属于数据链路层的一个字层，称为活动控制子层（Medium Access Control, MAC）。</li><li>介质访问控制方法<table><thead><tr><th><strong>分类</strong></th><th><strong>方法</strong></th><th><strong>描述</strong></th><th></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>静态</td><td>信道划分介质访问控制</td><td>FDM：共享空间</td><td></td><td></td></tr><tr><td></td><td></td><td>TDM：共享时间。其中，STDM 统计时分多路或异步时分多路复用为改进技术，它并不固定分配时隙，而按需分配时隙</td><td></td><td>8000b&#x2F;s 线路分 4 个用户，TDM 最高每用户 2000b&#x2F;s，STDM8000b&#x2F;s</td></tr><tr><td></td><td></td><td>WDM：光的频分多路</td><td></td><td>需要合波器和分波器</td></tr><tr><td></td><td></td><td>CDM：即共享频率，又共享时间</td><td></td><td>CDMA 码分多址：不同码片序列正交</td></tr><tr><td>动态</td><td>随机访问介质访问控制</td><td></td><td></td><td></td></tr><tr><td>（不同协议核心思想：胜利者通过争用获得信道，为争用型协议）</td><td></td><td></td><td></td><td></td></tr></tbody></table></li></ol><p>ALOHA：随机接入系统</p><p>CS：载波侦听，就是发送前先要检测一下总线是否空闲</p><p>MA：多路检测</p><p>CD：碰撞检测</p><p>CA：碰撞避免 | ALOHA<br>——总线型，无线信道 | 纯 ALOHA：想发就发 |<br>|<br>| | | | 时隙 ALOHA：划分等长时隙，每个时隙开始时才可发送一个帧 | |<br>| | | CSMA | 1-坚持 CSMA | 发前侦听，空闲就发，忙则<strong>持续</strong>侦听 |<br>| | | | 非-坚持 CSMA | 发前侦听，空闲就发，忙则<strong>放弃</strong>侦听，随机时间后重复 |<br>| | | | P-坚持 CSMA | 发前侦听，空闲以概率 P 发，忙则<strong>以概率 1-P 推迟</strong>到下一个时隙 |<br>| | | CSMA&#x2F;CA<br>——适用于总线型或半双工或以太网网络环境 | 先听后发，边听边发（区别于 CSMA），冲突停发，随机重发 | |<br>| | | CSMA&#x2F;CD<br>——应用于无线局域网 | 使用二进制退避算法。任何站发送数据帧时不仅要等待一个时间间隔还要进入争用窗口，并计算随机退避时间。仅当检测到信道空闲且这个数据帧是要发送的第一个数据帧时才不使用退避算法。</p><p>三种机制进行碰撞避免：<br>① 预约信道<br>②ACK 帧<br>③RTS&#x2F;CTS 帧（Request To Send, Clear To Send），解决“隐蔽站”问题 | |<br>| | 轮询访问介质访问控制 | 令牌传递协议 | 既不共享时间也不共享空间，实际上是在随机介质访问控制的基础上，限定了有权利发送数据的结点只有一个 | |</p><ol start="3"><li>争用期：2t</li><li>最小帧长问题</li></ol><p><img src="https://cdn.nlark.com/yuque/__latex/f25c0540b83f0196efa285bca222464a.svg#card=math&code=%E6%9C%80%E5%B0%8F%E5%B8%A7%E9%95%BF%3D%E6%80%BB%E7%BA%BF%E4%BC%A0%E6%92%AD%E6%97%B6%E5%BB%B6%2A%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E7%8E%87%2A2&height=24&width=297"></p><ol start="5"><li>二进制退避算法<ol><li>原因：避免两结点紧接着发送冲突帧</li><li>注意<ol><li>新的退避时间 &#x3D; <img src="https://cdn.nlark.com/yuque/__latex/70976af72a9ee0e1e31238fea934a695.svg#card=math&code=%E7%A6%BB%E6%95%A3%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E4%B8%AD%5B0%2C2%5Ek-1%5D%2A2rt&height=25&width=218"></li><li>重传参数 k≤10，即无论重传多少次，<strong>k 最大不超过 10</strong></li><li>重传达到<strong>16 次</strong>时，认为此帧永远无法正确发出，向高层抛出错误</li></ol></li></ol></li><li>CSMA&#x2F;CD 与 CSMA&#x2F;CA 的区别<ol><li>CSMA&#x2F;CD 可以检测冲突，但无法避免；CSMA&#x2F;CA 发送包的的同时不能检测到信道上有无冲突，本结点没有冲突不意味着在接收结点就没有冲突，只能尽量避免</li><li>传输介质不同。CSMA&#x2F;CD 用于总线型以太网，CSMA&#x2F;CA 用于无线局域网 802.11a&#x2F;b&#x2F;g&#x2F;n 等</li><li>检测方式不同。CSMA&#x2F;CD 通过电缆电压变化来检测；而 CSMA&#x2F;CA 采用能量检测、载波检测和能量载波混合检测三种检测信道空闲的方式</li><li>在本结点有（无）冲突，并不意味着在接收结点处就有（无）冲突</li></ol></li><li>使用 CSMA&#x2F;CD 的条件<ol><li>总线形线路（非点对点）</li><li>存在最小帧长（PPP 就不需要）</li></ol></li></ol><p><strong>总结：</strong>CSMA&#x2F;CA 协议的基本思想是在发送数据时先广播告知其它结点，让其它结点在某段时间内不要发送数据，以免出现碰撞。CSMA&#x2F;CD 协议的基本思想是发送前侦听，边发送边侦听，一旦出现碰撞马上停止发送。</p><ol start="7"><li>轮询问题<ol><li>轮询开销</li><li>等待延迟</li><li>单点故障</li></ol></li><li>令牌问题<ol><li>令牌开销</li><li>等待延迟</li><li>单点故障</li></ol></li></ol><h3 id="（六）局域网"><a href="#（六）局域网" class="headerlink" title="（六）局域网"></a>（六）局域网</h3><ol><li><p>LAN：是指在较小地理范围内，将计算机、外部设备和数据库系统等通过<strong>基带同轴电缆粗缆（10BASE5）、基带同轴电缆细缆（10BASE2）、非屏蔽双绞线（10BASE-T）和光纤（10BASE-FL）</strong>等连接介质互相连接起来，组成资源信息共享的计算机互联网络。</p></li><li><p>特点</p><ol><li>为一个单位所有，地理范围和数目有限</li><li>所有站点共享较高的的带宽</li><li>较低的时延和误码率</li><li>各站点为平等关系，而非主从</li><li>能进行广播和组播</li></ol></li><li><p>决定局域网特性的三要素</p><ol><li>拓扑结构</li><li>传输介质</li><li>介质访问控制方式（决定技术特性）</li></ol></li><li><p>局域网拓扑的结构</p><ol><li>星形结构</li><li>总线形结构</li><li>环形结构</li><li>星形和总线形结合的复合结构</li></ol></li><li><p>局域网常用介质控制方法</p><ol><li>CSMA&#x2F;CD（前两种应用于总线型网）</li><li>令牌总线</li><li>令牌环（应用于令牌环网）</li></ol></li><li><p>三种特殊局域网拓扑实现</p><table><thead><tr><th></th><th>物理拓扑</th><th>逻辑拓扑</th></tr></thead><tbody><tr><td>以太网</td><td>星形或拓展星形</td><td>总线形</td></tr><tr><td>令牌环</td><td>星形</td><td>环形</td></tr><tr><td>FDFI（光纤分布数字接口）</td><td>双环结构</td><td>环形</td></tr></tbody></table></li><li><p>IEEE 802 下的局域网参考模型</p><ol><li>对应于 OSI 参考模型的数据链路层和物理层</li><li>并被拆分<table><thead><tr><th></th><th>介绍</th><th>主要功能</th></tr></thead><tbody><tr><td>MAC（媒体接入控制）</td><td>放入与接入传输媒体有关的内容，向上屏蔽对物理层访问的各种差异，提供对物理层统一访问接口</td><td>组帧和拆卸帧、比特传输差错检测、透明传输</td></tr><tr><td>LLC（逻辑链路控制）</td><td>与传输媒体无关，它向网络层提供无确认无连接、面向连接、带确认无连接、高速传送四种不同的连接服务类型</td><td>LLC 已经逐步被淘汰</td></tr></tbody></table></li></ol></li><li><p>以太网与 IEEE 802.3</p></li></ol><p>严格来说以太网应该是符合 DIX Ethernet V2 标准的局域网，但其与 IEEE 802.3 差异甚小，因此通常称 IEEE 802.3 局域网为以太网。</p><ol start="9"><li>以太网简化通信的两种措施<ol><li>采用无连接的工作方式</li><li>不对发送的数据帧编号，也不要求接收方发送确认，即以最大努力交付数据，提供的是不可靠服务，对于纠错功能由高层提供（传输层）。</li></ol></li><li>网络接口板</li></ol><p>网络接口卡，装有处理器和存储器，是工作在数据链路层的网路组件。另外，网卡控制着主机对介质的访问，因此网卡也工作在物理层，因为它只关注比特，而不关注任何高层信息。</p><ol start="11"><li>MAC 帧格式：<strong>P108</strong></li><li>高速以太网</li><li>100BASE-T 以太网：双绞线，全双工+半双工（全双工下不支持 CSMA&#x2F;CD）</li><li>吉比特以太网：向后兼容，全双工+半双工</li><li>10 吉比特以太网：仅光纤，仅全双工，无争用不使用 CSMA&#x2F;CD</li><li>IEEE 802.11</li></ol><p>无线局域网系列标准。<br>注意：① 无线局域网中，即使发生碰撞，也要把数据帧发送完；② 有线局域网中，检测到碰撞就立即停止发送数据。</p><ol start="14"><li>无线局域网的分类</li><li>固定基础设施无线局域网</li><li>无固定基础设施无线局域网自组织网络</li></ol><h3 id="（七）广域网"><a href="#（七）广域网" class="headerlink" title="（七）广域网"></a>（七）广域网</h3><ol><li>概念：覆盖范围很广的长距离网络。广域网不等于互联网，互联网可以连接不同类型的网络，通常使用路由器来连接</li><li>构成：广域网由一些结点交换机（注意不是路由器，结点交换机和路由器都用来转发分组，它们的工作原理也类似。结点交换机在单个网络中转发分组，而路由器在多个网络构成的互联网中转发分组）及连接这些交换机的链路组成。结点交换机的功能是存储转发</li><li>广域网的重要问题：① 路由选择；② 分组转发</li><li>如何理解“局域网主要使用的协议在数据链路层，广域网使用的协议主要在网络层。”这句话？</li></ol><p>如果网络中的两个结点要进行数据交换，那么结点除要给出数据外，还要给数据“包装”上一层控制信息，用于实现检错纠错等功能。如果这层控制信息是数据链路层协议的控制信息，那么就称使用了数据链路层协议；如果这层控制信息是网络层的控制信息，那么就称使用了网络层协议</p><ol start="4"><li><p>广域网与局域网的区别和联系</p><table><thead><tr><th></th><th>广域网</th><th>局域网</th></tr></thead><tbody><tr><td>覆盖范围</td><td>广很，通常跨区域</td><td>较小，通常在一个区域内</td></tr><tr><td>连接方式</td><td>节点之间都是点到点连接，但为了提高网络的可靠性，一个节点交换机往往与多个节点交换机相连</td><td>普遍采用多点接入技术</td></tr><tr><td>OSI 层次</td><td>三层：物理层、数据链路层和网络层</td><td>两层：物理层和数据链路层</td></tr><tr><td>联系和相似点</td><td></td><td></td></tr></tbody></table></li><li><p>广域网和局域网都是互联网的重要组成构件，从互联网的角度看，二者平等（不是包含关系）</p></li><li><p>连接到一个广域网或一个局域网的主机在该网内进行通信时只需要知道其网络的物理地址<br>| |<br>| 着重点 | 强调资源共享 | 强调数据传输 |</p></li><li><p>广域网数据链路层控制协议</p><table><thead><tr><th></th><th>PPP 协议（<strong>P119</strong>）</th><th></th></tr></thead><tbody><tr><td>特点</td><td>只支持全双工，不提供可靠传输</td><td></td></tr><tr><td>描述</td><td>使用串行线路通信的面向字节的协议</td><td></td></tr><tr><td>组成部分</td><td>链路控制协议 LCP</td><td>一种扩展链路控制协议，用于建立（身份验证）、配置、测试和管理数据链路</td></tr><tr><td></td><td>网络控制协议 NCP</td><td>PPP 允许采用多种网络层协议，每个网络层协议用一个相应的 NCP 来配置，为网络层协议建立和配置逻辑链接</td></tr><tr><td></td><td>一个将 IP 数据包封装到串行链路的方法</td><td>IP 数据包在其中就是信息部分，这个长度受最大传说送单元 MTU 限制</td></tr><tr><td>PPP 帧格式</td><td>标志字段 F：7E(01111101)</td><td>1B</td></tr><tr><td></td><td>地址字段 A：0xFF</td><td>1B</td></tr><tr><td></td><td>控制字段 C：0x03</td><td>1B</td></tr><tr><td></td><td>协议字段</td><td>2B</td></tr><tr><td></td><td>信息部分</td><td>0-1500B</td></tr><tr><td></td><td>FCS</td><td>2B</td></tr><tr><td></td><td>标志字段 F</td><td>1B</td></tr></tbody></table></li></ol><table><thead><tr><th></th><th>HDLC 协议</th></tr></thead><tbody><tr><td>特点</td><td>采用全双工，提供可靠传输</td></tr><tr><td>描述</td><td>面向比特的数据链路层协议</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><ol start="6"><li>PPP 与 HDLC 的不同点</li></ol><h3 id="（八）数据链路层设备"><a href="#（八）数据链路层设备" class="headerlink" title="（八）数据链路层设备"></a>（八）数据链路层设备</h3><ol><li><p>网桥</p><blockquote><p>都是根据往返时间来判断是否可达</p></blockquote><ol><li>透明网桥（自学习生成树，不是最佳路由）</li><li>源路由网桥（最佳路由）</li></ol></li><li><p>局域网交换机</p><table><thead><tr><th></th><th align="center">不同点</th><th></th></tr></thead><tbody><tr><td>直通式交换机</td><td align="center"></td><td></td></tr></tbody></table></li><li><p>只检查帧的目的地址</p></li><li><p>速度快，缺乏安全性</p></li><li><p>无法支持具有不同速率的端口的交换<br>| |<br>| 存储转发式交换机 |</p></li><li><p>先接收到帧缓存，检查数据是否正确，再转发</p></li><li><p>可靠性高，延迟大</p></li><li><p>能支持不同速率端口之间的转换<br>| |</p></li></ol><h3 id="（九）疑难点总结"><a href="#（九）疑难点总结" class="headerlink" title="（九）疑难点总结"></a>（九）疑难点总结</h3><ol><li>冲突域和广播域</li></ol><p><strong>CONTINUE…</strong><br><a href="https://www.yuque.com/u1063509/st66mv/tdt0gb?view=doc_embed">计算机网络 PART2</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/yuque/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/yuque/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇将记录本人在考研复习数据结构中所遇到的相关知识点<br>部分代码：<a href="https://gitee.com/ammazzing/DS">https://gitee.com/ammazzing/DS</a></p></blockquote><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><ol><li>Catalan 数</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/yuque/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/yuque/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><h4 id="生产者与消费者"><a href="#生产者与消费者" class="headerlink" title="生产者与消费者"></a>生产者与消费者</h4><h4 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h4><p>问题分析</p><blockquote><p>读者写者问题最核心的问题是如何处理多个读者可以同时对文件的读操作。PV 过程其实就是对共享文件加锁解锁的过程，所以可以让第一个访问文件的的读进程加锁，最后一个访问文件的进程解锁。</p></blockquote><p>读&#x2F;写进程优先的问题</p><h4 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h4><h4 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h4><h3 id="同步关系的处理"><a href="#同步关系的处理" class="headerlink" title="同步关系的处理"></a>同步关系的处理</h3><ol><li>分析进程行为，在可能阻塞的地方 P 一下，再分析可以在哪里将其唤醒（V 一下），最后再确定信号量的初值和含义。即，先确定 PV 操作的位置，再确定应该对应什么信号量。</li><li>PV 操作的顺序：</li></ol><p>先判断空满，再判断是否有互斥访问。</p><ol start="3"><li>信号量初值<ul><li>同步信号量初值 &#x3D; 资源数；</li><li>互斥信号量初值 &#x3D; 1；</li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理</title>
      <link href="/yuque/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
      <url>/yuque/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h3><blockquote><p>移码 &#x3D; 补码符号位取反</p></blockquote><p><strong>定义：移码 &#x3D; 真值 + 偏置值</strong><br><strong>偏置值 &#x3D; 2</strong><br>注：IEEE754 的偏置值为 2-1</p><h3 id="规格化浮点数的特点"><a href="#规格化浮点数的特点" class="headerlink" title="规格化浮点数的特点"></a>规格化浮点数的特点</h3><h4 id="用原码表示的尾数进行规格化"><a href="#用原码表示的尾数进行规格化" class="headerlink" title="用原码表示的尾数进行规格化"></a>用原码表示的尾数进行规格化</h4><blockquote><p>只需要保证最高数值位（非符号位）为 1。</p></blockquote><table><thead><tr><th></th><th>格式</th><th>最大值</th><th>最小值</th><th>表示范围</th></tr></thead><tbody><tr><td>正数</td><td>0.1XXX…XXX</td><td>0.111…111</td><td>0.1000…000</td><td>[1&#x2F;2, 1-2]</td></tr><tr><td>负数</td><td>1.1XXX…XXX</td><td>1.1000…000</td><td>1.111…111</td><td>[-(1-2-n), -1&#x2F;2]</td></tr></tbody></table><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="用补码表示的尾数进行规格化"><a href="#用补码表示的尾数进行规格化" class="headerlink" title="用补码表示的尾数进行规格化"></a>用补码表示的尾数进行规格化</h3><blockquote><p>正数只需保证最高数值位为 1；负数规定数值位最高位为 0；口诀：必须保证符号位和最高数值位不一样，即 0.1 或 1.0（便于计算机判断是否规格化）。</p></blockquote><table><thead><tr><th></th><th>格式</th><th>最大值</th><th>最小值</th><th>表示范围</th></tr></thead><tbody><tr><td>正数</td><td>0.1XXX…XXX</td><td>0.111…111</td><td>0.1000…000</td><td>[1&#x2F;2, 1-2]</td></tr><tr><td>负数</td><td>1.0XXX…XXX</td><td>1.0111…111</td><td>1.000…000</td><td>[-1, -(1&#x2F;2+2-n)]</td></tr></tbody></table><h3 id="IEEE-754"><a href="#IEEE-754" class="headerlink" title="IEEE 754"></a>IEEE 754</h3><table><thead><tr><th>阶码表示范围</th><th>最小绝对值</th><th>最大绝对值</th><th>备注</th></tr></thead><tbody><tr><td>-126 ~ 127</td><td>尾数全 0，阶码真值最小-126，对应移码 0000 0001</td><td>尾数全 1，阶码真值最大 127，对应移码 1111 1110</td><td>-127(全 0)，128(全 1)对应着特殊用途</td></tr></tbody></table><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="浮点数加减的步骤"><a href="#浮点数加减的步骤" class="headerlink" title="浮点数加减的步骤"></a>浮点数加减的步骤</h3><p>转换格式 &gt; 对阶 &gt; 尾数加减 &gt; 规格化 &gt; 舍入 &gt; 判断溢出</p><h3 id="常见知识点总结"><a href="#常见知识点总结" class="headerlink" title="常见知识点总结"></a>常见知识点总结</h3><h4 id="冯诺依曼体系结构"><a href="#冯诺依曼体系结构" class="headerlink" title="冯诺依曼体系结构"></a>冯诺依曼体系结构</h4><p>冯·诺依曼提出了计算机制造的三个基本原则，即采用二进制逻辑、程序存储执行以及计算机由五个部分组成（运算器、控制器、存储器、输入设备、输出设备），这套理论被称为冯·诺依曼体系结构。</p><h4 id="DRAM-刷新原理"><a href="#DRAM-刷新原理" class="headerlink" title="DRAM 刷新原理"></a>DRAM 刷新原理</h4><p>遵循电容存储电荷的原理，有则 1，无则 0。电容只能维持 1~2ms，即使电源不掉电，信息也会自动消失，必须在消失之前进行恢复。</p><h4 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h4><p>奇校验：添加一位校验码之后，1 的个数为奇数；偶校验：添加一位校验码后，1 的个数为偶数。</p><h4 id="-2"><a href="#-2" class="headerlink" title=""></a></h4><h4 id="刷新的实质"><a href="#刷新的实质" class="headerlink" title="刷新的实质"></a>刷新的实质</h4><p>按行读出，再原样写入。</p><h4 id="字、位扩充与芯片选择"><a href="#字、位扩充与芯片选择" class="headerlink" title="字、位扩充与芯片选择"></a>字、位扩充与芯片选择</h4><p>一定是先进行位扩充，再进行字扩充。存放系统程序选用 ROM，存放用户程序选用 RAM。</p><h4 id="存储器扩充的连线原则"><a href="#存储器扩充的连线原则" class="headerlink" title="存储器扩充的连线原则"></a>存储器扩充的连线原则</h4><p>CS 为片选信号线，WE 读写信号线，低电平有效；位扩充中，所有存储芯片的片选信号线是连在一起的，而字扩充中需要片选信号区分不同的芯片，片选信号线是分开的（CS、CS）。</p><h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><p>CPU 从主存取指令或取数据，在一定时间内，只是对主存的局部地址区域进行访问。</p><h4 id="Cache-的原理"><a href="#Cache-的原理" class="headerlink" title="Cache 的原理"></a>Cache 的原理</h4><p>程序的局部性原理</p><h4 id="Cache-和主存的编址"><a href="#Cache-和主存的编址" class="headerlink" title="Cache 和主存的编址"></a>Cache 和主存的编址</h4><p>主存的地址分为两部分：高 m 位表示主存的块地址，低 b 位表示其块内地址的字或者字节数，则 M&#x3D;2 表示主存的总块数；<br>Cache 的地址分为两部分：高 c 位为 Cache 的块号。当然，Cache 的总块数远小于主存块数 M。</p><h4 id="-3"><a href="#-3" class="headerlink" title=""></a></h4><h4 id="Cache-的相关计算"><a href="#Cache-的相关计算" class="headerlink" title="Cache 的相关计算"></a>Cache 的相关计算</h4><p>命中率为 h，t 为命中时访问 Cache 的时间，t 为未命中时的主存访问时间<br>平均访问时间：t&#x3D; ht + (1-h)t<br>Cache-主存系统效率：e &#x3D; t&#x2F; t</p><h4 id="Cache-与主存的映射方式"><a href="#Cache-与主存的映射方式" class="headerlink" title="Cache 与主存的映射方式"></a>Cache 与主存的映射方式</h4><p>直接映射：i &#x3D; j mod C，适合大容量 Cache<br>全相联映射：允许映射到任意一块 Cache，适合小容量 Cache<br>组相联映射（组内全相联，组间直接映射）</p><h4 id="LRU-近期最少使用算法"><a href="#LRU-近期最少使用算法" class="headerlink" title="LRU 近期最少使用算法"></a>LRU 近期最少使用算法</h4><p>只记录每个块最近一次使用的时间。</p><h4 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h4><ol><li>页式虚拟存储器</li><li>段式虚拟存储器</li><li>段页式虚拟存储器</li></ol><h4 id="虚实地址变换"><a href="#虚实地址变换" class="headerlink" title="虚实地址变换"></a>虚实地址变换</h4><h4 id="外部存储器-磁盘"><a href="#外部存储器-磁盘" class="headerlink" title="外部存储器-磁盘"></a>外部存储器-磁盘</h4><p>道密度：指的是磁盘沿半径方向单位长度的磁道数；<br>线密度（位密度）：指的是单位长度磁道能记录二进制信息的位数；<br>存储容量 &#x3D; nks，n 为存放信息盘面数、k 为每个盘面磁道数、s 为每条磁道信息数<br>平均寻址时间 &#x3D; 1&#x2F;2(min + max)<br>数据传输率 &#x3D; 每道数据量 * 转速</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>经典算法题</title>
      <link href="/yuque/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%A2%98/"/>
      <url>/yuque/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="天勤算法题积累"><a href="#天勤算法题积累" class="headerlink" title="天勤算法题积累"></a>天勤算法题积累</h3><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h4 id="寻找主元素"><a href="#寻找主元素" class="headerlink" title="寻找主元素"></a>寻找主元素</h4><blockquote><p>线性表真题 3：一个数组有 N 个元素，其中有超过 N&#x2F;2 的元素相同，请找出这个元素。时间复杂度为 O(n)。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果一个数组中存在一个主元素（个数大于n/2），如果两个不相等的元素两两抵消，那么最终一定剩下的是主元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">major_element</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* non-negative returned if major element exist. */</span></span><br><span class="line"><span class="type">int</span> seed = A[<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> p;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(seed == A[i])</span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">if</span>(cnt&gt;<span class="number">0</span>) cnt--;</span><br><span class="line"><span class="keyword">else</span> seed = A[i];</span><br><span class="line">&#125;</span><br><span class="line">cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">if</span>(A[i] == seed) cnt++;</span><br><span class="line"><span class="keyword">if</span>(cnt &gt; (n&gt;&gt;<span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="-2"><a href="#-2" class="headerlink" title=""></a></h4><h4 id="求-N-个字符的全排列"><a href="#求-N-个字符的全排列" class="headerlink" title="求 N 个字符的全排列"></a>求 N 个字符的全排列</h4><blockquote><p><em>栈与队列思考题 2：对 n 个不同的字符进行全排列。</em></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *设str是含有n个不同字符的数组例如12345，perm（str,k,n）为str[0]~str[k]的所有字符全排序输出函数，</span></span><br><span class="line"><span class="comment"> *n为str数组字符个数。以此类推，perm(str,k-1,n)处理的字符个数比perm(str,k,n)处理的字符个数少一个。</span></span><br><span class="line"><span class="comment"> *假定perm(str,k-1,n)可求，对于第k个位置可以任取str[0]~str[k-1]内任意元素作为str[k]，</span></span><br><span class="line"><span class="comment"> *再组合perm(str,k+1,n)得到perm(str,k,n)。再递归之前先选取一个元素和位置k的元素交换，这一级递归完成之后，</span></span><br><span class="line"><span class="comment"> *再把元素交换回来，保证初始元素顺序不改变，以实现所有字符都能在位置k上完成一次递归。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">perm</span><span class="params">(<span class="type">int</span> str[], <span class="type">int</span> k, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) cout &lt;&lt; str[i];</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            temp = str[k];</span><br><span class="line">            str[k] = str[i];</span><br><span class="line">            str[i] = temp; <span class="comment">//任取str[i]与str[k]交换</span></span><br><span class="line">            <span class="built_in">perm</span>(str, k<span class="number">-1</span>, n);</span><br><span class="line">            temp = str[k];</span><br><span class="line">            str[k] = str[i];</span><br><span class="line">            str[i] = temp; <span class="comment">//还原str[k]和str[i]得到原始数组，下次再任取</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo站点的优化方法</title>
      <link href="/optimization-of-hexo-site/"/>
      <url>/optimization-of-hexo-site/</url>
      
        <content type="html"><![CDATA[<h4 id="使用USTC-Google-Fonts加速服务"><a href="#使用USTC-Google-Fonts加速服务" class="headerlink" title="使用USTC Google Fonts加速服务"></a>使用USTC Google Fonts加速服务</h4><p>谷歌字体api在国内的使用体验一直很差，所以当我想用自己喜欢的字体的时候从google fonts加载过来就会很慢，用户体验极差。<br>使用USTC Google Fonts加速服务其实很简单，将<code>theme/next/_config.xml</code>中<code>fonts</code>中的<code>host</code>选项设置为<code>fonts.lug.ustc.edu.cn</code>即可（默认为：<code>fonts.googleapi.com</code>）。具体可以<code>参考参考资料１</code>。</p><h4 id="将Github-Pages部署到Netlify"><a href="#将Github-Pages部署到Netlify" class="headerlink" title="将Github Pages部署到Netlify"></a>将Github Pages部署到Netlify</h4><h4 id="将博客迁移至Coding-Pages"><a href="#将博客迁移至Coding-Pages" class="headerlink" title="将博客迁移至Coding Pages"></a>将博客迁移至Coding Pages</h4><ol><li><p>国外的cdn解析始终是差点意思，将静态博客迁移至<code>Coding.net</code>提供的<code>Coding Pages</code>服务，体验比<code>Github Pages</code>和<code>Netlify</code>好得多。</p></li><li><p>本篇文章不讨论个人服务器部署。</p></li></ol><h4 id="使用阿里云OSS存储"><a href="#使用阿里云OSS存储" class="headerlink" title="使用阿里云OSS存储"></a>使用阿里云OSS存储</h4><pre><code>在阿里云上开通OSS存储，搭建自己的图床等。</code></pre><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ol><li><a href="https://lug.ustc.edu.cn/wiki/lug/services/googlefonts">LUG@USTC Google Fonts加速服务</a></li><li><a href="http://theme-next.iissnan.com/theme-settings.html#fonts-customization">Next最新使用文档</a></li><li><a href="https://io-oi.me/">优秀博客</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习笔记 3</title>
      <link href="/git-study-note-3/"/>
      <url>/git-study-note-3/</url>
      
        <content type="html"><![CDATA[<h4 id="fetch、pull与push"><a href="#fetch、pull与push" class="headerlink" title="fetch、pull与push"></a>fetch、pull与push</h4><ol><li>了解fast-forwards</li><li>fetch从远端拉到本地保持一致</li><li>当remote与本地仓库不一致时的处理办法</li></ol><ul><li>先fetch再merge</li><li>直接pull</li><li>git rebase</li></ul><ol start="3"><li>推送到remote</li></ol><h4 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h4><h5 id="不同人修改不同文件该如何处理"><a href="#不同人修改不同文件该如何处理" class="headerlink" title="不同人修改不同文件该如何处理"></a>不同人修改不同文件该如何处理</h5><pre><code>git merge同一开发分支。</code></pre><h5 id="不同人修改了相同文件的不同区域"><a href="#不同人修改了相同文件的不同区域" class="headerlink" title="不同人修改了相同文件的不同区域"></a>不同人修改了相同文件的不同区域</h5><pre><code>协作前git pull保持仓库最新，再进行push（留意ahead与behind信息）。</code></pre><h5 id="不同人修改了同文件的同一区域"><a href="#不同人修改了同文件的同一区域" class="headerlink" title="不同人修改了同文件的同一区域"></a>不同人修改了同文件的同一区域</h5><pre><code>及时pull来同步变更，这个情况会提示conflict，这时需要打开冲突文件（文件内会有提示信息），选择保留的信息并删除提示信息。修改完成后提交commit再进行push。</code></pre><h5 id="不同人同时变更了文件名及其内容"><a href="#不同人同时变更了文件名及其内容" class="headerlink" title="不同人同时变更了文件名及其内容"></a>不同人同时变更了文件名及其内容</h5><pre><code>pull最新内容。当其中一位开发人员变更了姓名与其内容之后，另一位开发人员直接进行pull即可。</code></pre><h5 id="多人修改文件名"><a href="#多人修改文件名" class="headerlink" title="多人修改文件名"></a>多人修改文件名</h5><pre><code>当该情况发生时，后提交的开发人员执行pull之后会报conflict，并保留了这两个不同文件名的文件为两个独立文件。两人协商后选择保留一份，git add [要保留的文件]、git rm [不需要保留的文件]，再进行commit，最后push。</code></pre><h5 id="禁止向继承分支执行push-f"><a href="#禁止向继承分支执行push-f" class="headerlink" title="禁止向继承分支执行push -f"></a>禁止向继承分支执行push -f</h5><pre><code>-f: force updates</code></pre><h5 id="禁止向集成分支执行变更历史的操作"><a href="#禁止向集成分支执行变更历史的操作" class="headerlink" title="禁止向集成分支执行变更历史的操作"></a>禁止向集成分支执行变更历史的操作</h5><pre><code>公共的分支进制被拉到本地进行rebase行为。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习笔记 2</title>
      <link href="/git-study-note-2/"/>
      <url>/git-study-note-2/</url>
      
        <content type="html"><![CDATA[<h4 id="commit-tree与blob的对应关系"><a href="#commit-tree与blob的对应关系" class="headerlink" title="commit, tree与blob的对应关系"></a>commit, tree与blob的对应关系</h4><ol><li>一个commit对应一个tree（唯一一个）</li><li>一个tree可以看作是一次commit之后整个项目的一个快照</li><li>一个tree可能也会包含多个tree</li><li>一个blob对应一个文件</li></ol><h4 id="分离头指针注意的问题"><a href="#分离头指针注意的问题" class="headerlink" title="分离头指针注意的问题"></a>分离头指针注意的问题</h4><pre><code>当切换到没有绑定分支的commit时，并对其当中的文件修改，最终提交commit保存后会出现&quot;warning: you are leaving 1 sommit behind, not connected to any of your branches.&quot;这时的commit被git看作不重要，可能会被git所清理，如果你要保存这个commit就要新建分支（git branch new-branch-name [分支hash]）</code></pre><h4 id="删除不需要的分支"><a href="#删除不需要的分支" class="headerlink" title="删除不需要的分支"></a>删除不需要的分支</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d [branch-name / hash]</span><br></pre></td></tr></table></figure><h4 id="修改commit和massage"><a href="#修改commit和massage" class="headerlink" title="修改commit和massage"></a>修改commit和massage</h4><ol><li>修改最新的commit</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><ol start="2"><li>修改老旧的commit</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i [privious-commit-hash]</span><br><span class="line"># 按照提示修改</span><br><span class="line"># 将pick改为reward</span><br></pre></td></tr></table></figure><ol start="3"><li>合并多次的commit</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i [oldest-commit-hash]</span><br><span class="line"># 按照提示修改</span><br><span class="line"># 将pick改为squash</span><br></pre></td></tr></table></figure><ol start="4"><li>合并不连续的commit</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i [oldest-commit-hash]</span><br><span class="line"># 未显示出来的需要用到的commit要按照先后顺序手动添加进来</span><br><span class="line"># 把要合并的commit按照先后顺序放在一起</span><br><span class="line"># 将pick改为squash</span><br></pre></td></tr></table></figure><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><h5 id="文件的差异"><a href="#文件的差异" class="headerlink" title="文件的差异"></a>文件的差异</h5><ol><li>比较暂存区与head指向的文件差异</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached</span><br></pre></td></tr></table></figure><ol start="2"><li>比较工作区与暂存区文件差异</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br><span class="line"># 所以说git diff命令默认比较的是工作区和暂存区的区别，默认所有文件</span><br><span class="line"></span><br><span class="line">git diff -- file.name</span><br><span class="line"># 指定文件的差异</span><br></pre></td></tr></table></figure><h5 id="文件提交与回退"><a href="#文件提交与回退" class="headerlink" title="文件提交与回退"></a>文件提交与回退</h5><ol><li><p>暂存区恢复成和HEAD一样</p><p> 命令：git reset HEAD <file>…</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD</span><br><span class="line"># 清空暂存区所有文件（即取消暂存）</span><br></pre></td></tr></table></figure><ol start="2"><li><p>工作区恢复成和暂存区一样</p><p> 命令：git checkout – <file>…</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- file.name</span><br></pre></td></tr></table></figure><ol start="3"><li><p>取消暂存区部分文件的暂存</p><p> 命令：git reset HEAD <file>…</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git resset HEAD -- file1.name file2.name # ...</span><br></pre></td></tr></table></figure><ol start="4"><li>清除最近几次提交</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard [target-commit-hash]</span><br></pre></td></tr></table></figure><ol start="5"><li>查看不同提交的指定文件的差异</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 比较两分支的差异</span><br><span class="line">git diff branch1 branch2</span><br><span class="line"># 比较特定文件</span><br><span class="line">git diff branch1 branch2 -- file.name</span><br><span class="line"></span><br><span class="line"># 直接比较两个commit</span><br><span class="line">git diff commit-hash-1 commit-hash-2 -- file.name</span><br></pre></td></tr></table></figure><ol start="6"><li>删除文件的正确方法</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm file.name</span><br></pre></td></tr></table></figure><ol start="7"><li>紧急任务处理</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 保存当前状态以便处理紧急事件</span><br><span class="line">git stash</span><br><span class="line"># 处理完之后再恢复</span><br><span class="line">git stash pop # 或 git stash apply</span><br><span class="line"></span><br><span class="line"># pop 和 apply的区别</span><br><span class="line"># pop恢复并丢掉stash list内容，apply不会</span><br><span class="line"></span><br><span class="line"># 查看stash列表</span><br><span class="line">git stash list</span><br></pre></td></tr></table></figure><h5 id="指定不需要git管理的文件"><a href="#指定不需要git管理的文件" class="headerlink" title="指定不需要git管理的文件"></a>指定不需要git管理的文件</h5><pre><code>.gitignore文件</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective Python 学习笔记 4</title>
      <link href="/effective-python-study-note-4/"/>
      <url>/effective-python-study-note-4/</url>
      
        <content type="html"><![CDATA[<h4 id="尽量使用异常来表示特殊情况，而不要返回None"><a href="#尽量使用异常来表示特殊情况，而不要返回None" class="headerlink" title="尽量使用异常来表示特殊情况，而不要返回None"></a>尽量使用异常来表示特殊情况，而不要返回None</h4><pre><code>    _表示用不到的变量</code></pre><h5 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h5><ol><li>用None这个返回值来表示特殊意义的函数，很容易使调用者犯错，以为None和0及空字符串之类的值，在表达式里面都会评估为False</li><li>函数遇到特特殊情况时应该抛出异常，而不是返回None</li></ol><h4 id="了解如何在闭包里使用外围作用域中的变量"><a href="#了解如何在闭包里使用外围作用域中的变量" class="headerlink" title="了解如何在闭包里使用外围作用域中的变量"></a>了解如何在闭包里使用外围作用域中的变量</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    eg. 有一份列表，其中元素都是数字，现在对其排序，要把出现在某个群组内的数字，放在群组外的那些数字之前。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sort_pri</span>(<span class="params">values, group</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">in</span> group:</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">0</span>, x)</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span>, x)</span><br><span class="line">    values.sort(key = helper)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        上述函数成立的原因：</span></span><br><span class="line"><span class="string">            1. 函数是一等对象(first-class object)</span></span><br><span class="line"><span class="string">            2. python支持闭包</span></span><br><span class="line"><span class="string">            3. python中使用特殊的规则来比较两个元组。它首先比较各元组中下标为0的对应元素，如果相等，再比较下标为1的元素，如果还是想等，就继续依次比较。</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>]</span><br><span class="line">group = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;</span><br><span class="line">sort_pri(numbers, group)</span><br><span class="line"><span class="built_in">print</span>(numbers)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure><h5 id="要点-1"><a href="#要点-1" class="headerlink" title="要点"></a>要点</h5><ol><li>对于定义在某作用域内的闭包来说，它可以引用这些作用域中的变量</li><li>使用默认方式对闭包内的变量赋值，不会影响外围作用域的同名变量</li><li>在python 3中，程序可以在闭包内用nonlocal语句来修饰某个名称，使该闭包能够修改外围作用域中的同名变量</li><li>除了简单的函数，尽量不要使用nonlocal语句</li></ol><h4 id="考虑使用生成器来改写直接返回列表的函数"><a href="#考虑使用生成器来改写直接返回列表的函数" class="headerlink" title="考虑使用生成器来改写直接返回列表的函数"></a>考虑使用生成器来改写直接返回列表的函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># eg.返回字符串中英文单词的首字母和其下标</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index_words</span>(<span class="params">text</span>):</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">if</span> text:</span><br><span class="line">        result.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> index, letter <span class="keyword">in</span> <span class="built_in">enumerate</span>(text):</span><br><span class="line">        <span class="keyword">if</span> letter == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">            result.append(index + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">words = <span class="string">&#x27;I am python&#x27;</span></span><br><span class="line">re = index_words(words)</span><br><span class="line"><span class="built_in">print</span>(re)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>以上程序的问题：</p><ol><li>代码拥挤，每次找到新的结果，都要调用append方法。而我们真正强调的不是对append的调用，而是该方法给列表中添加的那个值且函数首位都要对resut进行创建和返回</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成器改写</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>)words_iter(text):</span><br><span class="line">    <span class="keyword">if</span> text:</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> index, letter <span class="keyword">in</span> <span class="built_in">enumerate</span>(text):</span><br><span class="line">        <span class="keyword">if</span> letter == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">            <span class="keyword">yield</span> index + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">### ···</span></span><br><span class="line"></span><br><span class="line">    re = <span class="built_in">list</span>(index_words_iter(address))</span><br></pre></td></tr></table></figure><ol start="2"><li>index_words函数在它返回前，要把所有结果都放在列表中。如果数据量非常大，那么程序可能会耗尽内存。用生成器改写后，可以应对任意长度的输入数据</li></ol><h5 id="要点-2"><a href="#要点-2" class="headerlink" title="要点"></a>要点</h5><ol><li>使用时生成器比用list返回结果更加清晰</li><li>由生成器函数所返回的那个迭代器，可以把生成器函数体中，传给yield表达式的那些值，逐次生产出来</li><li>无论数据量多大，生成器都能产生一系列输出，不会对内存造成压力</li></ol><h4 id="在参数上面迭代时要多加小心"><a href="#在参数上面迭代时要多加小心" class="headerlink" title="在参数上面迭代时要多加小心"></a>在参数上面迭代时要多加小心</h4><pre><code>    细节见书本第17条</code></pre><h5 id="要点-3"><a href="#要点-3" class="headerlink" title="要点"></a>要点</h5><ol><li>如果参数是迭代器，那么可能会导致奇怪的行为并错失某些值</li><li>python的迭代器协议，描述了容器和迭代器应该如何与iter和next内置函数、for循环及相关表达式相互配合</li><li>把__iter__方法时限为生成器，即可定义自己的容器类型</li><li>想判断某个值是迭代器还是容器，可以拿该值为参数，两侧调用iter函数，若结果相同，则是迭代器，调用内置的next函数，即可令该迭代器前进一步</li></ol><h4 id="用数量可变的位置参数减少视觉杂讯"><a href="#用数量可变的位置参数减少视觉杂讯" class="headerlink" title="用数量可变的位置参数减少视觉杂讯"></a>用数量可变的位置参数减少视觉杂讯</h4><pre><code>    令函数接受可选位置参数（由于这种参数习惯上写为*args，所以又称为star args，星号参数），能够使代码更加清晰，并减少视觉杂讯（visual noise）。    visual noise：一种比喻，意思是使代码看起来不要太过杂乱，以强调其中的重要内容。</code></pre><h5 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h5><ol><li>变长参数在传给函数时，总是先转化为元组。这就意味着，如果用带有*操作符的生成器为参数，来调用这种参数，python必须把该生成器完整迭代一轮，并把所生成的每个值，都放入元组之中。这可能会消耗大量内存。所以只有当我们确定参数个数较少时，才采用这种写法</li><li>如果以后要给函数添加新的位置参数，那就必须修改原来调用该函数的那些旧代码</li></ol><h5 id="要点-4"><a href="#要点-4" class="headerlink" title="要点"></a>要点</h5><ol><li>def语句中用*args，即可令函数接受数量可变的位置参数</li><li>调用函数时，可以采用*操作符，把序列中的元素当成位置参数，传给该函数</li><li>对生成器使用*操作符，可能导致内存耗尽</li><li>在已经接受*args参数的函数上继续添加位置参数，可能会产生难以排查的bug</li></ol><h4 id="用关键字参数来表达可选行为"><a href="#用关键字参数来表达可选行为" class="headerlink" title="用关键字参数来表达可选行为"></a>用关键字参数来表达可选行为</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">arg1, arg2</span>):</span><br><span class="line">    <span class="keyword">return</span> arg1 + arg2</span><br><span class="line"><span class="comment"># 以下写法等效</span></span><br><span class="line">func(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">func(arg1 = <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">func(<span class="number">1</span>, arg2 = <span class="number">1</span>)</span><br><span class="line">func(arg1 = <span class="number">1</span>, arg2 = <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h5 id="关键字参数的好处"><a href="#关键字参数的好处" class="headerlink" title="关键字参数的好处"></a>关键字参数的好处</h5><ol><li>易于理解，参数含义与参数值都呈现在面前</li><li>可以在函数中提供默认值</li><li>它可以提供一种扩充函数参数的有效方式，使得扩充之后的函数依然能与原有的那些调用代码兼容</li></ol><h5 id="要点-5"><a href="#要点-5" class="headerlink" title="要点"></a>要点</h5><ol><li>函数参数可以按照位置或关键字来指定</li><li>只是用位置参数来调用函数，可能会导致这些参数数值含义不够明确，而关键字参数则能够阐明每个参数的意图</li><li>给函数添加新行为时，可以使用带默认值的关键字参数，以便与原有的函数点用代码保持兼容</li><li>可选的关键字参数，总是应该以关键字形式来指定，而不是以位置参数的形式来指定</li></ol><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ol><li><a href="https://blog.csdn.net/u013380694/article/details/90019571">python 闭包和装饰器详解</a></li><li><a href="https://www.runoob.com/python3/python3-att-list-sort.html">Python3 List sort()方法</a></li><li><a href="https://www.jianshu.com/p/9dd355ab4e5d">深入理解 Python yield</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective Python 学习笔记 3</title>
      <link href="/effective-python-study-note-3/"/>
      <url>/effective-python-study-note-3/</url>
      
        <content type="html"><![CDATA[<h4 id="不要在for和while循环后面写else语句块"><a href="#不要在for和while循环后面写else语句块" class="headerlink" title="不要在for和while循环后面写else语句块"></a>不要在for和while循环后面写else语句块</h4><pre><code>Python提供了一种很多编程语言都不支持的功能，可以在循环内部的语句块后面直接写else块。</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Loop %s&#x27;</span> % i)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Loop done!&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">Loop <span class="number">0</span></span><br><span class="line">Loop <span class="number">1</span></span><br><span class="line">Loop <span class="number">2</span></span><br><span class="line">Loop done!</span><br><span class="line"><span class="comment"># 即程序没有成功执行完，就会执行else语句</span></span><br></pre></td></tr></table></figure><h5 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h5><ol><li>只有当整个循环猪蹄都没有遇到break语句时，循环后面的else块才会执行</li><li>循环后加else块，这种写法不直观，又容易引起误解</li></ol><h4 id="合理利用try-x2F-except-x2F-else-x2F-finally结构中的每个代码块"><a href="#合理利用try-x2F-except-x2F-else-x2F-finally结构中的每个代码块" class="headerlink" title="合理利用try&#x2F;except&#x2F;else&#x2F;finally结构中的每个代码块"></a>合理利用try&#x2F;except&#x2F;else&#x2F;finally结构中的每个代码块</h4><h5 id="finally块"><a href="#finally块" class="headerlink" title="finally块"></a>finally块</h5><ul><li>如果既要将异常向上传播，又要在异常发生时执行清理工作，尝试使用try&#x2F;finally结构</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是一项常见的用途，就是确保能够可靠的关闭文件句柄</span></span><br><span class="line">handle = <span class="built_in">open</span>(<span class="string">&#x27;file&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    data = handle.read()</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    handle.close()</span><br><span class="line"><span class="comment"># read方法所抛出的异常会向上传播给调用方，而finally块中的close方法将一定会被执行。</span></span><br><span class="line"><span class="comment"># open方法一定要放在try之外，因为如果打开文件时发生异常，那么程序应该跳过finally块。</span></span><br></pre></td></tr></table></figure><h5 id="else块"><a href="#else块" class="headerlink" title="else块"></a>else块</h5><ul><li>try&#x2F;except&#x2F;else结构可以清晰地描述出哪些异常会由自己地代码处理、哪些异常会传播到上一级。</li><li>如果try没有异常，那么就执行else块。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_json_key</span>(<span class="params">data, key</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        result_dict = json.loads(data)</span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">raise</span> KeyError <span class="keyword">from</span> e</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> result_dict[key]</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/jpch89/article/details/84315444">Raise和Raise…from…的区别</a></p><h5 id="混合使用"><a href="#混合使用" class="headerlink" title="混合使用"></a>混合使用</h5><pre><code>详见书本</code></pre><h5 id="要点-1"><a href="#要点-1" class="headerlink" title="要点"></a>要点</h5><ol><li>无论try块是否发生异常，都可利用try&#x2F;finally符合语句中的finally块来执行清理工作</li><li>else块可以用来缩减try块中的代码量，并把没有发生异常时索要执行的语句与try&#x2F;except代码块隔开</li><li>顺利运行try块后，若想使某些操作能在finally块的清理代码之前执行，则可将这些操作写到else块中</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective Python 学习笔记 2</title>
      <link href="/effective-python-study-note-2/"/>
      <url>/effective-python-study-note-2/</url>
      
        <content type="html"><![CDATA[<h4 id="用列表推导来取代map和filter"><a href="#用列表推导来取代map和filter" class="headerlink" title="用列表推导来取代map和filter"></a>用列表推导来取代map和filter</h4><pre><code>列表推导(list commprehension)：根据一份列表来制作另外一份列表</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    用列表每个元素平方值构建另一份列表</span></span><br><span class="line"><span class="string">    a = [1, 2, 3, 4, 5, 6, 7, 8]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 列表推导写法</span></span><br><span class="line">squares = [x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> a]</span><br><span class="line"><span class="comment"># map写法</span></span><br><span class="line">squares = <span class="built_in">map</span>(lamda x: x ** <span class="number">2</span>, a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 条件输出</span></span><br><span class="line"><span class="comment"># 列表推导输出偶数</span></span><br><span class="line">squares = [x <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> a%<span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"><span class="comment"># map辅以filter输出偶数</span></span><br><span class="line">squares = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x, <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, a))</span><br></pre></td></tr></table></figure><pre><code>    字典与集也有类似的推导机制，编写算法时，可以通过这些推导机制来创建衍生的数据结构。</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">chile_ranks = &#123;<span class="string">&#x27;ghost&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;god&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;man&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line">rank_dict = &#123;rank: name <span class="keyword">for</span> name,rank <span class="keyword">in</span> chile_ranks.items()&#125;</span><br><span class="line">chile_len_set = &#123;<span class="built_in">len</span>(name) <span class="keyword">for</span> name <span class="keyword">in</span> rank_dict.values()&#125;</span><br><span class="line"><span class="built_in">print</span>(rank_dict)</span><br><span class="line"><span class="built_in">print</span>(chile_len_set)</span><br><span class="line"></span><br><span class="line"><span class="comment">#元组与dict互转</span></span><br><span class="line"><span class="built_in">tuple</span> = <span class="built_in">dict</span>.items()</span><br><span class="line"><span class="built_in">dict</span> = <span class="built_in">tuple</span>.values</span><br></pre></td></tr></table></figure><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ol><li>不使用含有两个以上表达式的列表推导，难理解尽量避免</li><li>列表推导支持多级循环，每一级循环也支持多项条件</li></ol><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol><li>数据量较少时，不会出现问题，数据量较多时可能会耗费大量内存</li></ol><h4 id="用生成器表达式来改写数据量较大的列表推导"><a href="#用生成器表达式来改写数据量较大的列表推导" class="headerlink" title="用生成器表达式来改写数据量较大的列表推导"></a>用生成器表达式来改写数据量较大的列表推导</h4><h5 id="什么是生成器"><a href="#什么是生成器" class="headerlink" title="什么是生成器"></a>什么是生成器</h5><pre><code>    通过列表生成式，我们可以直接创建一个列表，但是，受到内存限制，列表容量肯定是有限的，而且创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。    所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间，在Python中，这种一边循环一边计算的机制，称为生成器：generator。</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    eg. 读取日志文件</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">it = (<span class="built_in">len</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;/var/log.log&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(it)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x101b81480</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;logs&quot;</span></span><br></pre></td></tr></table></figure><h5 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h5><ol><li>当输入数据量较大时，列表推导可能会因为占用太多内存而出现问题</li><li>由生成器表达式返回的迭代器，可以逐次产生输出值，从而避免内存用量问题</li><li>把某个生成器表达式所返回的迭代器，放在另一个生成器表达式的for子表达式中，即可将二者结合起来</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">res = ((x, x ** <span class="number">2</span>) <span class="keyword">for</span> x <span class="keyword">in</span> a)</span><br></pre></td></tr></table></figure><ol start="4"><li>串在一起的生成器表达式执行速度很快</li></ol><h4 id="尽量用enumerate取代range"><a href="#尽量用enumerate取代range" class="headerlink" title="尽量用enumerate取代range"></a>尽量用enumerate取代range</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    场景说明：当想同时打印元素在列表中的索引和值的时候，使用range略显生硬</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># range写法</span></span><br><span class="line"><span class="keyword">for</span> i <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="built_in">list</span>)):</span><br><span class="line">    value = <span class="built_in">list</span>[i]</span><br><span class="line">    index = i</span><br><span class="line"><span class="comment"># enumerate写法</span></span><br><span class="line"><span class="keyword">for</span> i, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">list</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%d: %s&#x27;</span> % (i + <span class="number">1</span>, value))</span><br></pre></td></tr></table></figure><h5 id="要点-1"><a href="#要点-1" class="headerlink" title="要点"></a>要点</h5><ol><li>尽量使用enumerate来改写那种将range与下标访问结合的序列遍历代码</li><li>可以给enumerate提供第二个参数， 以指定开始计数时所用的值</li></ol><h4 id="用zip函数同时遍历两个迭代器"><a href="#用zip函数同时遍历两个迭代器" class="headerlink" title="用zip函数同时遍历两个迭代器"></a>用zip函数同时遍历两个迭代器</h4><pre><code>zip可以将两个或者多个迭代器封装成一个生成器</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    场景说明：需要平行对两个列表进行操作时</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">names = [<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;cendy&#x27;</span>]</span><br><span class="line">letters = [<span class="built_in">len</span>(n) <span class="keyword">for</span> n <span class="keyword">in</span> names]</span><br><span class="line"></span><br><span class="line">longest_name = <span class="literal">None</span></span><br><span class="line">max_letters = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, count <span class="keyword">in</span> <span class="built_in">zip</span>(names, letters):</span><br><span class="line">    <span class="keyword">if</span> count &gt; max_letters:</span><br><span class="line">        longest_name = name</span><br><span class="line">        max_letters = count</span><br><span class="line"><span class="built_in">print</span>(longest_name)</span><br></pre></td></tr></table></figure><h5 id="要点-2"><a href="#要点-2" class="headerlink" title="要点"></a>要点</h5><ol><li>内置的zip函数可以平行地遍历多个迭代器</li><li>python3中的zip函数相当于生成器，会在遍历过程中产生元组</li><li>如果提供的迭代器长度不等，那么zip会自动提前终止</li><li>itertools内置模块中的zip_longest函数可以平行的遍历多个迭代器，而不用在乎他们的长度是否相等</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective Python 学习笔记 1</title>
      <link href="/effective-python-study-note-1/"/>
      <url>/effective-python-study-note-1/</url>
      
        <content type="html"><![CDATA[<h4 id="PEP-8规范"><a href="#PEP-8规范" class="headerlink" title="PEP 8规范"></a>PEP 8规范</h4><h5 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h5><ol><li>使用下标获取列表元素、调用函数或者给关键字参数赋值时，不在两旁加空格</li><li>函数、变量及属性应该用小写字母来拼写，个单词之间下划线相连</li><li>受保护实例属性以单个下划线开头：_protect_var</li><li>类与异常，以每个单词首字母大写形式命名：ClassName</li><li>模块级别的常量，采用全部大写字母方式命名，单词之间下划线连接：ALL_CAPS</li><li>类中实例方法（instance method），应该把首个参数命名为self，以表示该对象自身</li><li>类方法（class method）的首个参数应该命名为cls，以表示该类自身</li></ol><h5 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h5><ol><li>不要不要通过检测长度的办法（如 if len(somelist) &#x3D;&#x3D; 0）来判断somelist是否为[]或’’等空值，而是采用if not somelist这种写法来判断，它会假定：空值将自动评估为false</li><li>不要编写单行的if、for、while及except语句，应该分开书写以示清晰</li><li>import语句应总是放在开头</li><li>引入模块时，总是使用绝对名称，而不是根据当前面模块路径来使用相对名称：from bar import foo</li><li>如果一定要引用相对名称，采用from . import foo的格式</li><li>import语句应该按顺序划分成三个部分，分别表示标准库模块、第三方模块以及自用模块，在每个部分中import语句应该按照模块的字母顺序排列</li></ol><h4 id="bytes、str与unicode的区别"><a href="#bytes、str与unicode的区别" class="headerlink" title="bytes、str与unicode的区别"></a>bytes、str与unicode的区别</h4><ol><li><p>把Unicode字符转换成二进制数据就必须使用encode方法</p></li><li><p>把二进制数据字符转换成Unicode就必须使用decode方法</p></li><li><p>实现：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">to_str</span>(<span class="params">bytes_or_str</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(bytes_or_str, <span class="built_in">bytes</span>):</span><br><span class="line">        value = bytes_or_str.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        value = bytes_or_str</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">to_bytes</span>(<span class="params">str_to_bytes</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(str_to_bytes, <span class="built_in">str</span>):</span><br><span class="line">        value = str_to_bytes.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        value = str_to_bytes</span><br><span class="line">    <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure></li><li><p>编写程序时，一定要把编码和解码操作放在界面外围来做。程序最核心的部分应该使用Unicode字符类型，而且不对编码做任何假设。这种方法既可以令程序接受多种类型的文本编码（如Latin-1、Shift JIS和Big 5），又可以保证输出的文本信息只采用一种编码形式（最好是UTF-8）</p></li><li><p>open函数添加了名为encoding的新参数，默认值为utf-8，这就要求再写入时必须传入unicode字符的str实例，而不接受二进制数据的bytes实例。解决方法：采用字符写入模式wb，读取采用rb，如：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;file.txt&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(os.urandom(<span class="number">10</span>))</span><br></pre></td></tr></table></figure></li></ol><h4 id="用辅助函数取代复杂的表达式"><a href="#用辅助函数取代复杂的表达式" class="headerlink" title="用辅助函数取代复杂的表达式"></a>用辅助函数取代复杂的表达式</h4><pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    eg. 需求：查询字符串</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> parse_qs</span><br><span class="line">    my_values = parse_qs(<span class="string">&#x27;red=5&amp;blue=0&amp;green=&#x27;</span>, keep_blank_values=<span class="literal">True</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(my_values))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">&#x27;red&#x27;</span>: [<span class="string">&#x27;5&#x27;</span>], <span class="string">&#x27;blue&#x27;</span>: [<span class="string">&#x27;0&#x27;</span>], <span class="string">&#x27;green&#x27;</span>: [<span class="string">&#x27;&#x27;</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法一：用get方法在my_values字典中查询不同参数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;RED:     &#x27;</span>, my_values.get(<span class="string">&#x27;red&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;GREEN:   &#x27;</span>, my_values.get(<span class="string">&#x27;green&#x27;</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>RED:       [<span class="string">&#x27;5&#x27;</span>]</span><br><span class="line">    GREEN:     [<span class="string">&#x27;&#x27;</span>]     <span class="comment">#无法将空值输出为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#方法二</span></span><br><span class="line">green = <span class="built_in">int</span>(my_values.get(<span class="string">&#x27;green&#x27;</span>, [])[<span class="number">0</span>] <span class="keyword">or</span> <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;GREEN:   %r&#x27;</span> % green)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>GREEN:   <span class="number">0</span>  <span class="comment">#表达式复杂，不易理解</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 总结辅助函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_first_int</span>(<span class="params">values, key, default=<span class="number">0</span></span>):</span><br><span class="line">    found = values.get(key, [<span class="string">&#x27;&#x27;</span>])</span><br><span class="line">    <span class="keyword">if</span> found[<span class="number">0</span>]:</span><br><span class="line">        found = found[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        found = default</span><br><span class="line">    <span class="keyword">return</span> found</span><br><span class="line"></span><br><span class="line">green = get_first_int(my_values, <span class="string">&#x27;green&#x27;</span>)</span><br></pre></td></tr></table></figure></code></pre><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol><li>用if&#x2F;else表达式会比用or或and这样的Boolean操作符更清晰</li></ol><h4 id="了解切割序列的办法"><a href="#了解切割序列的办法" class="headerlink" title="了解切割序列的办法"></a>了解切割序列的办法</h4><h5 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h5><p>somelist[start:end]</p><ol><li>如果从头切片，将start留空，而非写0. end同理</li><li>在源列表进行切割之后，会产生一份全新的列表。系统依然维护着指向原列表中各个对象的引用。</li><li>在赋值时采用切割操作会改变原列表：a[2:7] &#x3D; [1, 2, 3]</li><li>单词切片操作内不要同时指定start、end和stride</li><li>反转字符串：re &#x3D; str[::-1]</li><li>第五条只对ASCII字符有效，对已经编码成utf-8字符串的Unicode字符无效</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows-pip-is-configured-with-locations-that-require-TLS-SSL</title>
      <link href="/windows-pip-is-configured-with-locations-that-require-TLS-SSL/"/>
      <url>/windows-pip-is-configured-with-locations-that-require-TLS-SSL/</url>
      
        <content type="html"><![CDATA[<h4 id="本机环境"><a href="#本机环境" class="headerlink" title="本机环境"></a>本机环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Windows 10 64位</span><br><span class="line"></span><br><span class="line">Anaconda python 3.7</span><br></pre></td></tr></table></figure><h4 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">is</span> configured <span class="keyword">with</span> locations that require TLS/SSL, however the ssl module <span class="keyword">in</span> Python <span class="keyword">is</span> <span class="keyword">not</span> available.</span><br></pre></td></tr></table></figure><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><h5 id="原因：Anaconda-环境变量未配置完全"><a href="#原因：Anaconda-环境变量未配置完全" class="headerlink" title="原因：Anaconda 环境变量未配置完全"></a><em>原因：Anaconda 环境变量未配置完全</em></h5><h5 id="需要配置的环境变量"><a href="#需要配置的环境变量" class="headerlink" title="需要配置的环境变量"></a>需要配置的环境变量</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D:\ProgramData\Anaconda3</span><br><span class="line"></span><br><span class="line">D:\ProgramData\Anaconda3\Scripts</span><br><span class="line"></span><br><span class="line">D:\ProgramData\Anaconda3\Library\bin</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> anaconda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h4 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h4><h5 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h5 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h5 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h5 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
